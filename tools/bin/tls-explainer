#!/usr/bin/env python3
"""TLS message explainer.
"""

import argparse
import struct
import sys
from typing import List, Tuple


class Wire:
    """Explain a wire dump of one side of a TLS communication."""

    def __init__(self) -> None:
        # Incomplete handshake fragment
        self.handshake_message = b''

    @staticmethod
    def _chunk(data: bytes, text: str) -> None:
        first_part = data[:8]
        print(first_part.hex() +
              ' ' * (20 - 2 * len(first_part)) +
              text)
        for offset in range(8, len(data), 8):
            print(data[offset:offset+8].hex())

    def _chunk_int(self, value: int, width: int, text: str) -> None:
        if width > 8:
            raise ValueError(f'_chunk_int(width={width})')
        data = value.to_bytes(width, byteorder='big')
        self._chunk(data, text)

    @staticmethod
    def _record_type_name(record_type: int) -> str:
        return {
            20: 'change_cipher_spec',
            21: 'alert',
            22: 'handshake',
            23: 'application_data',
        }.get(record_type, '(unknown type)')

    @staticmethod
    def _version_name(version_major: int, version_minor: int) -> str:
        return {
            (1, 0): 'SSL 1.0',
            (2, 0): 'SSL 2.0',
            (3, 0): 'SSL 3.0',
            (3, 1): 'TLS 1.0',
            (3, 2): 'TLS 1.2',
            (3, 3): 'TLS 1.2',
            (3, 4): 'TLS 1.3',
            (254, 253): 'DTLS 1.2',
            (254, 255): 'DTLS 1.0',
        }.get((version_major, version_minor), '(unknown version)')

    @staticmethod
    def _alert_level_name(alert_level: int) -> str:
        return {
            1: 'warning',
            2: 'fatal',
        }.get(alert_level, '(unknown alert level)')

    @staticmethod
    def _alert_description_name(alert_description: int) -> str:
        return {
            0: 'close_notify',
            10: 'unexpected_message',
            20: 'bad_record_mac',
            21: 'decryption_failed',
            22: 'record_overflow',
            30: 'decompression_failure',
            40: 'handshake_failure',
            41: 'no_certificate',
            42: 'bad_certificate',
            43: 'unsupported_certificate',
            44: 'certificate_revoked',
            45: 'certificate_expired',
            46: 'certificate_unknown',
            47: 'illegal_parameter',
            48: 'unknown_ca',
            49: 'access_denied',
            50: 'decode_error',
            51: 'decrypt_error',
            60: 'export_restriction',
            70: 'protocol_version',
            71: 'insufficient_security',
            80: 'internal_error',
            90: 'user_canceled',
            100: 'no_renegotiation',
            110: 'unsupported_extension',
        }.get(alert_description, '(unknown alert description)')

    def process_change_cipher_spec_record(self, payload: bytes) -> None:
        if len(payload) == 1:
            self._chunk(payload, '  ChangeCipherSpec encrypt(1) (presumed)')
        else:
            self._chunk(payload, '  ChangeCipherSpec (invalid)')

    def process_alert_record(self, payload: bytes) -> None:
        if len(payload) == 2:
            self._chunk(payload[0:1],
                        '  level=' + self._alert_level_name(payload[0]))
            self._chunk(payload[1:2],
                        '  level=' + self._alert_description_name(payload[1]))
        else:
            self._chunk(payload, '  Alert (invalid)')

    def _advance_bytes(self, content: bytes, offset: int,
                       length_width: int, name: str, indent: int) -> \
            Tuple[bytes, int]:
        start = offset + length_width
        if len(content) < start:
            self._chunk(content[offset:],
                        ' ' * indent + name + ' (truncated length)')
            return len(content)
        self._chunk(b'', ' ' * indent + name)
        length = int.from_bytes(content[offset:start], 'big')
        self._chunk(content[offset:start],
                    ' ' * (indent + 2) + f'length={length}')
        end = offset + length_width + length
        return (content[start:end], end)

    def _advance_raw_bytes(self, content: bytes, offset: int, length_width: int,
                           name: str, indent: int) -> int:
        start = offset + length_width
        data, end = self._advance_bytes(content, offset,
                                        length_width, name, indent)
        if end <= len(content):
            self._chunk(content[start:end],
                        ' ' * (indent + 2) + 'content')
        else:
            self._chunk(content[start:],
                        ' ' * (indent + 2) + 'content (truncated)')
        return end

    def _advance_list(self, content: bytes, offset: int,
                      length_width: int, element_length: int,
                      name: str, indent: int) -> \
            Tuple[List[bytes], bytes, int]:
        start = offset + length_width
        if len(content) < start:
            self._chunk(content[offset:],
                        ' ' * indent + name + ' (truncated length)')
            return [], b'', len(content)
        self._chunk(b'', ' ' * indent + name)
        length = int.from_bytes(content[offset:start], 'big')
        self._chunk(content[offset:start],
                    ' ' * (indent + 2) + f'length={length}')
        end = offset + length_width + length
        last_element_end = end - (end - start) % element_length
        return ([content[n:n+element_length]
                 for n in range(start, last_element_end, element_length)],
                content[last_element_end:end],
                end)

    def _cipher_suite_name(self, num: int) -> str:
        return {
            0x0000: 'TLS_NULL_WITH_NULL_NULL',
            0x0001: 'TLS_RSA_WITH_NULL_MD5',
            0x0002: 'TLS_RSA_WITH_NULL_SHA',
            0x0003: 'TLS_RSA_EXPORT_WITH_RC4_40_MD5',
            0x0004: 'TLS_RSA_WITH_RC4_128_MD5',
            0x0005: 'TLS_RSA_WITH_RC4_128_SHA',
            0x0006: 'TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5',
            0x0007: 'TLS_RSA_WITH_IDEA_CBC_SHA',
            0x0008: 'TLS_RSA_EXPORT_WITH_DES40_CBC_SHA',
            0x0009: 'TLS_RSA_WITH_DES_CBC_SHA',
            0x000A: 'TLS_RSA_WITH_3DES_EDE_CBC_SHA',
            0x000B: 'TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA',
            0x000C: 'TLS_DH_DSS_WITH_DES_CBC_SHA',
            0x000D: 'TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA',
            0x000E: 'TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA',
            0x000F: 'TLS_DH_RSA_WITH_DES_CBC_SHA',
            0x0010: 'TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA',
            0x0011: 'TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA',
            0x0012: 'TLS_DHE_DSS_WITH_DES_CBC_SHA',
            0x0013: 'TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA',
            0x0014: 'TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA',
            0x0015: 'TLS_DHE_RSA_WITH_DES_CBC_SHA',
            0x0016: 'TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA',
            0x0017: 'TLS_DH_anon_EXPORT_WITH_RC4_40_MD5',
            0x0018: 'TLS_DH_anon_WITH_RC4_128_MD5',
            0x0019: 'TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA',
            0x001A: 'TLS_DH_anon_WITH_DES_CBC_SHA',
            0x001B: 'TLS_DH_anon_WITH_3DES_EDE_CBC_SHA',
            0x001E: 'TLS_KRB5_WITH_DES_CBC_SHA',
            0x001F: 'TLS_KRB5_WITH_3DES_EDE_CBC_SHA',
            0x0020: 'TLS_KRB5_WITH_RC4_128_SHA',
            0x0021: 'TLS_KRB5_WITH_IDEA_CBC_SHA',
            0x0022: 'TLS_KRB5_WITH_DES_CBC_MD5',
            0x0023: 'TLS_KRB5_WITH_3DES_EDE_CBC_MD5',
            0x0024: 'TLS_KRB5_WITH_RC4_128_MD5',
            0x0025: 'TLS_KRB5_WITH_IDEA_CBC_MD5',
            0x0026: 'TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA',
            0x0027: 'TLS_KRB5_EXPORT_WITH_RC2_CBC_40_SHA',
            0x0028: 'TLS_KRB5_EXPORT_WITH_RC4_40_SHA',
            0x0029: 'TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5',
            0x002A: 'TLS_KRB5_EXPORT_WITH_RC2_CBC_40_MD5',
            0x002B: 'TLS_KRB5_EXPORT_WITH_RC4_40_MD5',
            0x002C: 'TLS_PSK_WITH_NULL_SHA',
            0x002D: 'TLS_DHE_PSK_WITH_NULL_SHA',
            0x002E: 'TLS_RSA_PSK_WITH_NULL_SHA',
            0x002F: 'TLS_RSA_WITH_AES_128_CBC_SHA',
            0x0030: 'TLS_DH_DSS_WITH_AES_128_CBC_SHA',
            0x0031: 'TLS_DH_RSA_WITH_AES_128_CBC_SHA',
            0x0032: 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA',
            0x0033: 'TLS_DHE_RSA_WITH_AES_128_CBC_SHA',
            0x0034: 'TLS_DH_anon_WITH_AES_128_CBC_SHA',
            0x0035: 'TLS_RSA_WITH_AES_256_CBC_SHA',
            0x0036: 'TLS_DH_DSS_WITH_AES_256_CBC_SHA',
            0x0037: 'TLS_DH_RSA_WITH_AES_256_CBC_SHA',
            0x0038: 'TLS_DHE_DSS_WITH_AES_256_CBC_SHA',
            0x0039: 'TLS_DHE_RSA_WITH_AES_256_CBC_SHA',
            0x003A: 'TLS_DH_anon_WITH_AES_256_CBC_SHA',
            0x003B: 'TLS_RSA_WITH_NULL_SHA256',
            0x003C: 'TLS_RSA_WITH_AES_128_CBC_SHA256',
            0x003D: 'TLS_RSA_WITH_AES_256_CBC_SHA256',
            0x003E: 'TLS_DH_DSS_WITH_AES_128_CBC_SHA256',
            0x003F: 'TLS_DH_RSA_WITH_AES_128_CBC_SHA256',
            0x0040: 'TLS_DHE_DSS_WITH_AES_128_CBC_SHA256',
            0x0041: 'TLS_RSA_WITH_CAMELLIA_128_CBC_SHA',
            0x0042: 'TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA',
            0x0043: 'TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA',
            0x0044: 'TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA',
            0x0045: 'TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA',
            0x0046: 'TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA',
            0x0067: 'TLS_DHE_RSA_WITH_AES_128_CBC_SHA256',
            0x0068: 'TLS_DH_DSS_WITH_AES_256_CBC_SHA256',
            0x0069: 'TLS_DH_RSA_WITH_AES_256_CBC_SHA256',
            0x006A: 'TLS_DHE_DSS_WITH_AES_256_CBC_SHA256',
            0x006B: 'TLS_DHE_RSA_WITH_AES_256_CBC_SHA256',
            0x006C: 'TLS_DH_anon_WITH_AES_128_CBC_SHA256',
            0x006D: 'TLS_DH_anon_WITH_AES_256_CBC_SHA256',
            0x0084: 'TLS_RSA_WITH_CAMELLIA_256_CBC_SHA',
            0x0085: 'TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA',
            0x0086: 'TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA',
            0x0087: 'TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA',
            0x0088: 'TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA',
            0x0089: 'TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA',
            0x008A: 'TLS_PSK_WITH_RC4_128_SHA',
            0x008B: 'TLS_PSK_WITH_3DES_EDE_CBC_SHA',
            0x008C: 'TLS_PSK_WITH_AES_128_CBC_SHA',
            0x008D: 'TLS_PSK_WITH_AES_256_CBC_SHA',
            0x008E: 'TLS_DHE_PSK_WITH_RC4_128_SHA',
            0x008F: 'TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA',
            0x0090: 'TLS_DHE_PSK_WITH_AES_128_CBC_SHA',
            0x0091: 'TLS_DHE_PSK_WITH_AES_256_CBC_SHA',
            0x0092: 'TLS_RSA_PSK_WITH_RC4_128_SHA',
            0x0093: 'TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA',
            0x0094: 'TLS_RSA_PSK_WITH_AES_128_CBC_SHA',
            0x0095: 'TLS_RSA_PSK_WITH_AES_256_CBC_SHA',
            0x0096: 'TLS_RSA_WITH_SEED_CBC_SHA',
            0x0097: 'TLS_DH_DSS_WITH_SEED_CBC_SHA',
            0x0098: 'TLS_DH_RSA_WITH_SEED_CBC_SHA',
            0x0099: 'TLS_DHE_DSS_WITH_SEED_CBC_SHA',
            0x009A: 'TLS_DHE_RSA_WITH_SEED_CBC_SHA',
            0x009B: 'TLS_DH_anon_WITH_SEED_CBC_SHA',
            0x009C: 'TLS_RSA_WITH_AES_128_GCM_SHA256',
            0x009D: 'TLS_RSA_WITH_AES_256_GCM_SHA384',
            0x009E: 'TLS_DHE_RSA_WITH_AES_128_GCM_SHA256',
            0x009F: 'TLS_DHE_RSA_WITH_AES_256_GCM_SHA384',
            0x00A0: 'TLS_DH_RSA_WITH_AES_128_GCM_SHA256',
            0x00A1: 'TLS_DH_RSA_WITH_AES_256_GCM_SHA384',
            0x00A2: 'TLS_DHE_DSS_WITH_AES_128_GCM_SHA256',
            0x00A3: 'TLS_DHE_DSS_WITH_AES_256_GCM_SHA384',
            0x00A4: 'TLS_DH_DSS_WITH_AES_128_GCM_SHA256',
            0x00A5: 'TLS_DH_DSS_WITH_AES_256_GCM_SHA384',
            0x00A6: 'TLS_DH_anon_WITH_AES_128_GCM_SHA256',
            0x00A7: 'TLS_DH_anon_WITH_AES_256_GCM_SHA384',
            0x00A8: 'TLS_PSK_WITH_AES_128_GCM_SHA256',
            0x00A9: 'TLS_PSK_WITH_AES_256_GCM_SHA384',
            0x00AA: 'TLS_DHE_PSK_WITH_AES_128_GCM_SHA256',
            0x00AB: 'TLS_DHE_PSK_WITH_AES_256_GCM_SHA384',
            0x00AC: 'TLS_RSA_PSK_WITH_AES_128_GCM_SHA256',
            0x00AD: 'TLS_RSA_PSK_WITH_AES_256_GCM_SHA384',
            0x00AE: 'TLS_PSK_WITH_AES_128_CBC_SHA256',
            0x00AF: 'TLS_PSK_WITH_AES_256_CBC_SHA384',
            0x00B0: 'TLS_PSK_WITH_NULL_SHA256',
            0x00B1: 'TLS_PSK_WITH_NULL_SHA384',
            0x00B2: 'TLS_DHE_PSK_WITH_AES_128_CBC_SHA256',
            0x00B3: 'TLS_DHE_PSK_WITH_AES_256_CBC_SHA384',
            0x00B4: 'TLS_DHE_PSK_WITH_NULL_SHA256',
            0x00B5: 'TLS_DHE_PSK_WITH_NULL_SHA384',
            0x00B6: 'TLS_RSA_PSK_WITH_AES_128_CBC_SHA256',
            0x00B7: 'TLS_RSA_PSK_WITH_AES_256_CBC_SHA384',
            0x00B8: 'TLS_RSA_PSK_WITH_NULL_SHA256',
            0x00B9: 'TLS_RSA_PSK_WITH_NULL_SHA384',
            0x00BA: 'TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256',
            0x00BB: 'TLS_DH_DSS_WITH_CAMELLIA_128_CBC_SHA256',
            0x00BC: 'TLS_DH_RSA_WITH_CAMELLIA_128_CBC_SHA256',
            0x00BD: 'TLS_DHE_DSS_WITH_CAMELLIA_128_CBC_SHA256',
            0x00BE: 'TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256',
            0x00BF: 'TLS_DH_anon_WITH_CAMELLIA_128_CBC_SHA256',
            0x00C0: 'TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C1: 'TLS_DH_DSS_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C2: 'TLS_DH_RSA_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C3: 'TLS_DHE_DSS_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C4: 'TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C5: 'TLS_DH_anon_WITH_CAMELLIA_256_CBC_SHA256',
            0x00C6: 'TLS_SM4_GCM_SM3',
            0x00C7: 'TLS_SM4_CCM_SM3',
            0x00FF: 'TLS_EMPTY_RENEGOTIATION_INFO_SCSV',
            0x1301: 'TLS_AES_128_GCM_SHA256',
            0x1302: 'TLS_AES_256_GCM_SHA384',
            0x1303: 'TLS_CHACHA20_POLY1305_SHA256',
            0x1304: 'TLS_AES_128_CCM_SHA256',
            0x1305: 'TLS_AES_128_CCM_8_SHA256',
            0x1306: 'TLS_AEGIS_256_SHA512',
            0x1307: 'TLS_AEGIS_128L_SHA256',
            0x5600: 'TLS_FALLBACK_SCSV',
            0xC001: 'TLS_ECDH_ECDSA_WITH_NULL_SHA',
            0xC002: 'TLS_ECDH_ECDSA_WITH_RC4_128_SHA',
            0xC003: 'TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA',
            0xC004: 'TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA',
            0xC005: 'TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA',
            0xC006: 'TLS_ECDHE_ECDSA_WITH_NULL_SHA',
            0xC007: 'TLS_ECDHE_ECDSA_WITH_RC4_128_SHA',
            0xC008: 'TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA',
            0xC009: 'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA',
            0xC00A: 'TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA',
            0xC00B: 'TLS_ECDH_RSA_WITH_NULL_SHA',
            0xC00C: 'TLS_ECDH_RSA_WITH_RC4_128_SHA',
            0xC00D: 'TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA',
            0xC00E: 'TLS_ECDH_RSA_WITH_AES_128_CBC_SHA',
            0xC00F: 'TLS_ECDH_RSA_WITH_AES_256_CBC_SHA',
            0xC010: 'TLS_ECDHE_RSA_WITH_NULL_SHA',
            0xC011: 'TLS_ECDHE_RSA_WITH_RC4_128_SHA',
            0xC012: 'TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA',
            0xC013: 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA',
            0xC014: 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA',
            0xC015: 'TLS_ECDH_anon_WITH_NULL_SHA',
            0xC016: 'TLS_ECDH_anon_WITH_RC4_128_SHA',
            0xC017: 'TLS_ECDH_anon_WITH_3DES_EDE_CBC_SHA',
            0xC018: 'TLS_ECDH_anon_WITH_AES_128_CBC_SHA',
            0xC019: 'TLS_ECDH_anon_WITH_AES_256_CBC_SHA',
            0xC01A: 'TLS_SRP_SHA_WITH_3DES_EDE_CBC_SHA',
            0xC01B: 'TLS_SRP_SHA_RSA_WITH_3DES_EDE_CBC_SHA',
            0xC01C: 'TLS_SRP_SHA_DSS_WITH_3DES_EDE_CBC_SHA',
            0xC01D: 'TLS_SRP_SHA_WITH_AES_128_CBC_SHA',
            0xC01E: 'TLS_SRP_SHA_RSA_WITH_AES_128_CBC_SHA',
            0xC01F: 'TLS_SRP_SHA_DSS_WITH_AES_128_CBC_SHA',
            0xC020: 'TLS_SRP_SHA_WITH_AES_256_CBC_SHA',
            0xC021: 'TLS_SRP_SHA_RSA_WITH_AES_256_CBC_SHA',
            0xC022: 'TLS_SRP_SHA_DSS_WITH_AES_256_CBC_SHA',
            0xC023: 'TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256',
            0xC024: 'TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384',
            0xC025: 'TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256',
            0xC026: 'TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384',
            0xC027: 'TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256',
            0xC028: 'TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384',
            0xC029: 'TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256',
            0xC02A: 'TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384',
            0xC02B: 'TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256',
            0xC02C: 'TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384',
            0xC02D: 'TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256',
            0xC02E: 'TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384',
            0xC02F: 'TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256',
            0xC030: 'TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384',
            0xC031: 'TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256',
            0xC032: 'TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384',
            0xC033: 'TLS_ECDHE_PSK_WITH_RC4_128_SHA',
            0xC034: 'TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA',
            0xC035: 'TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA',
            0xC036: 'TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA',
            0xC037: 'TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256',
            0xC038: 'TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384',
            0xC039: 'TLS_ECDHE_PSK_WITH_NULL_SHA',
            0xC03A: 'TLS_ECDHE_PSK_WITH_NULL_SHA256',
            0xC03B: 'TLS_ECDHE_PSK_WITH_NULL_SHA384',
            0xC03C: 'TLS_RSA_WITH_ARIA_128_CBC_SHA256',
            0xC03D: 'TLS_RSA_WITH_ARIA_256_CBC_SHA384',
            0xC03E: 'TLS_DH_DSS_WITH_ARIA_128_CBC_SHA256',
            0xC03F: 'TLS_DH_DSS_WITH_ARIA_256_CBC_SHA384',
            0xC040: 'TLS_DH_RSA_WITH_ARIA_128_CBC_SHA256',
            0xC041: 'TLS_DH_RSA_WITH_ARIA_256_CBC_SHA384',
            0xC042: 'TLS_DHE_DSS_WITH_ARIA_128_CBC_SHA256',
            0xC043: 'TLS_DHE_DSS_WITH_ARIA_256_CBC_SHA384',
            0xC044: 'TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256',
            0xC045: 'TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384',
            0xC046: 'TLS_DH_anon_WITH_ARIA_128_CBC_SHA256',
            0xC047: 'TLS_DH_anon_WITH_ARIA_256_CBC_SHA384',
            0xC048: 'TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256',
            0xC049: 'TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384',
            0xC04A: 'TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256',
            0xC04B: 'TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384',
            0xC04C: 'TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256',
            0xC04D: 'TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384',
            0xC04E: 'TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256',
            0xC04F: 'TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384',
            0xC050: 'TLS_RSA_WITH_ARIA_128_GCM_SHA256',
            0xC051: 'TLS_RSA_WITH_ARIA_256_GCM_SHA384',
            0xC052: 'TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256',
            0xC053: 'TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384',
            0xC054: 'TLS_DH_RSA_WITH_ARIA_128_GCM_SHA256',
            0xC055: 'TLS_DH_RSA_WITH_ARIA_256_GCM_SHA384',
            0xC056: 'TLS_DHE_DSS_WITH_ARIA_128_GCM_SHA256',
            0xC057: 'TLS_DHE_DSS_WITH_ARIA_256_GCM_SHA384',
            0xC058: 'TLS_DH_DSS_WITH_ARIA_128_GCM_SHA256',
            0xC059: 'TLS_DH_DSS_WITH_ARIA_256_GCM_SHA384',
            0xC05A: 'TLS_DH_anon_WITH_ARIA_128_GCM_SHA256',
            0xC05B: 'TLS_DH_anon_WITH_ARIA_256_GCM_SHA384',
            0xC05C: 'TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256',
            0xC05D: 'TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384',
            0xC05E: 'TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256',
            0xC05F: 'TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384',
            0xC060: 'TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256',
            0xC061: 'TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384',
            0xC062: 'TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256',
            0xC063: 'TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384',
            0xC064: 'TLS_PSK_WITH_ARIA_128_CBC_SHA256',
            0xC065: 'TLS_PSK_WITH_ARIA_256_CBC_SHA384',
            0xC066: 'TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256',
            0xC067: 'TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384',
            0xC068: 'TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256',
            0xC069: 'TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384',
            0xC06A: 'TLS_PSK_WITH_ARIA_128_GCM_SHA256',
            0xC06B: 'TLS_PSK_WITH_ARIA_256_GCM_SHA384',
            0xC06C: 'TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256',
            0xC06D: 'TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384',
            0xC06E: 'TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256',
            0xC06F: 'TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384',
            0xC070: 'TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256',
            0xC071: 'TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384',
            0xC072: 'TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256',
            0xC073: 'TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384',
            0xC074: 'TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256',
            0xC075: 'TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384',
            0xC076: 'TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256',
            0xC077: 'TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384',
            0xC078: 'TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256',
            0xC079: 'TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384',
            0xC07A: 'TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC07B: 'TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC07C: 'TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC07D: 'TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC07E: 'TLS_DH_RSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC07F: 'TLS_DH_RSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC080: 'TLS_DHE_DSS_WITH_CAMELLIA_128_GCM_SHA256',
            0xC081: 'TLS_DHE_DSS_WITH_CAMELLIA_256_GCM_SHA384',
            0xC082: 'TLS_DH_DSS_WITH_CAMELLIA_128_GCM_SHA256',
            0xC083: 'TLS_DH_DSS_WITH_CAMELLIA_256_GCM_SHA384',
            0xC084: 'TLS_DH_anon_WITH_CAMELLIA_128_GCM_SHA256',
            0xC085: 'TLS_DH_anon_WITH_CAMELLIA_256_GCM_SHA384',
            0xC086: 'TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC087: 'TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC088: 'TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC089: 'TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC08A: 'TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC08B: 'TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC08C: 'TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256',
            0xC08D: 'TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384',
            0xC08E: 'TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256',
            0xC08F: 'TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384',
            0xC090: 'TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256',
            0xC091: 'TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384',
            0xC092: 'TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256',
            0xC093: 'TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384',
            0xC094: 'TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256',
            0xC095: 'TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384',
            0xC096: 'TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256',
            0xC097: 'TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384',
            0xC098: 'TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256',
            0xC099: 'TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384',
            0xC09A: 'TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256',
            0xC09B: 'TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384',
            0xC09C: 'TLS_RSA_WITH_AES_128_CCM',
            0xC09D: 'TLS_RSA_WITH_AES_256_CCM',
            0xC09E: 'TLS_DHE_RSA_WITH_AES_128_CCM',
            0xC09F: 'TLS_DHE_RSA_WITH_AES_256_CCM',
            0xC0A0: 'TLS_RSA_WITH_AES_128_CCM_8',
            0xC0A1: 'TLS_RSA_WITH_AES_256_CCM_8',
            0xC0A2: 'TLS_DHE_RSA_WITH_AES_128_CCM_8',
            0xC0A3: 'TLS_DHE_RSA_WITH_AES_256_CCM_8',
            0xC0A4: 'TLS_PSK_WITH_AES_128_CCM',
            0xC0A5: 'TLS_PSK_WITH_AES_256_CCM',
            0xC0A6: 'TLS_DHE_PSK_WITH_AES_128_CCM',
            0xC0A7: 'TLS_DHE_PSK_WITH_AES_256_CCM',
            0xC0A8: 'TLS_PSK_WITH_AES_128_CCM_8',
            0xC0A9: 'TLS_PSK_WITH_AES_256_CCM_8',
            0xC0AA: 'TLS_PSK_DHE_WITH_AES_128_CCM_8',
            0xC0AB: 'TLS_PSK_DHE_WITH_AES_256_CCM_8',
            0xC0AC: 'TLS_ECDHE_ECDSA_WITH_AES_128_CCM',
            0xC0AD: 'TLS_ECDHE_ECDSA_WITH_AES_256_CCM',
            0xC0AE: 'TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8',
            0xC0AF: 'TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8',
            0xC0B0: 'TLS_ECCPWD_WITH_AES_128_GCM_SHA256',
            0xC0B1: 'TLS_ECCPWD_WITH_AES_256_GCM_SHA384',
            0xC0B2: 'TLS_ECCPWD_WITH_AES_128_CCM_SHA256',
            0xC0B3: 'TLS_ECCPWD_WITH_AES_256_CCM_SHA384',
            0xC0B4: 'TLS_SHA256_SHA256',
            0xC0B5: 'TLS_SHA384_SHA384',
            0xC100: 'TLS_GOSTR341112_256_WITH_KUZNYECHIK_CTR_OMAC',
            0xC101: 'TLS_GOSTR341112_256_WITH_MAGMA_CTR_OMAC',
            0xC102: 'TLS_GOSTR341112_256_WITH_28147_CNT_IMIT',
            0xC103: 'TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_L',
            0xC104: 'TLS_GOSTR341112_256_WITH_MAGMA_MGM_L',
            0xC105: 'TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_S',
            0xC106: 'TLS_GOSTR341112_256_WITH_MAGMA_MGM_S',
            0xCCA8: 'TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256',
            0xCCA9: 'TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256',
            0xCCAA: 'TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256',
            0xCCAB: 'TLS_PSK_WITH_CHACHA20_POLY1305_SHA256',
            0xCCAC: 'TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256',
            0xCCAD: 'TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256',
            0xCCAE: 'TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256',
            0xD001: 'TLS_ECDHE_PSK_WITH_AES_128_GCM_SHA256',
            0xD002: 'TLS_ECDHE_PSK_WITH_AES_256_GCM_SHA384',
            0xD003: 'TLS_ECDHE_PSK_WITH_AES_128_CCM_8_SHA256',
            0xD005: 'TLS_ECDHE_PSK_WITH_AES_128_CCM_SHA256',
        }.get(num, '(unknown cipher suite)')

    def _advance_cipher_suites(self, content: bytes, offset: int) -> int:
        elements, trail, end = self._advance_list(content, offset,
                                                  2, 2, 'cipher_suites', 2)
        for elt in elements:
            name = self._cipher_suite_name(int.from_bytes(elt, 'big'))
            self._chunk(elt, '    ' + name)
        if trail:
            self._chunk(trail, 'truncated last element')
        return end

    @staticmethod
    def _compression_method_name(type_: int) -> str:
        return {
            0: 'null',
            1: 'zlib',
        }.get(type_, '(unknown compression method)')

    def _advance_compression_methods(self, content: bytes, offset: int) -> int:
        elements, trail, end = self._advance_list(content, offset,
                                                  1, 1, 'compression_methods', 2)
        for elt in elements:
            self._chunk(elt, '    ' + self._compression_method_name(elt[0]))
        return end

    @staticmethod
    def _extension_type_name(type_: int) -> str:
        return {
            0: 'server_name',
            1: 'max_fragment_length',
            2: 'client_certificate_url',
            3: 'trusted_ca_keys',
            4: 'truncated_hmac',
            5: 'status_request',
            6: 'user_mapping',
            7: 'client_authz',
            8: 'server_authz',
            9: 'cert_type',
            10: 'supported_groups (elliptic_curves)',
            11: 'ec_point_formats',
            12: 'srp',
            13: 'signature_algorithms',
            14: 'use_srtp',
            15: 'heartbeat',
            16: 'application_layer_protocol_negotiation',
            17: 'status_request_v2',
            18: 'signed_certificate_timestamp',
            19: 'client_certificate_type',
            20: 'server_certificate_type',
            21: 'padding',
            22: 'encrypt_then_mac',
            23: 'extended_master_secret',
            24: 'token_binding',
            25: 'cached_info',
            26: 'tls_lts',
            27: 'compress_certificate',
            28: 'record_size_limit',
            29: 'pwd_protect',
            30: 'pwd_clear',
            31: 'password_salt',
            32: 'ticket_pinning',
            33: 'tls_cert_with_extern_psk',
            34: 'delegated_credential',
            35: 'session_ticket',
            36: 'TLMSP',
            37: 'TLMSP_proxying',
            38: 'TLMSP_delegate',
            39: 'supported_ekt_ciphers',
            41: 'pre_shared_key',
            42: 'early_data',
            43: 'supported_versions',
            44: 'cookie',
            45: 'psk_key_exchange_modes',
            47: 'certificate_authorities',
            48: 'oid_filters',
            49: 'post_handshake_auth',
            50: 'signature_algorithms_cert',
            51: 'key_share',
            52: 'transparency_info',
            53: 'connection_id (deprecated)',
            54: 'connection_id',
            55: 'external_id_hash',
            56: 'external_session_id',
            57: 'quic_transport_parameters',
            58: 'ticket_request',
            59: 'dnssec_chain',
            60: 'sequence_number_encryption_algorithms',
            61: 'rrc',
            62: 'tls_flags',
            64768: 'ech_outer_extensions',
            65037: 'encrypted_client_hello',
            65281: 'renegotiation_info',
        }.get(type_, '(unknown extension type)')

    def process_client_supported_versions(self, data: bytes) -> None:
        if not data:
            return
        length = data[0]
        self._chunk(data[0:1], f'      inner length={length}')
        if 1 + length > len(data):
            self._chunk(data[1:], '      content (truncated)')
            return
        for n in range(1, length, 2):
            major = data[n]
            minor = data[n+1]
            self._chunk(data[n:n+2],
                        '      ' + self._version_name(major, minor))
        if length % 2 != 0:
            self._chunk(data[1+length%2:length],
                        '      (truncated last element)')
        if 1 + length < len(data):
            self._chunk(data[1+length:], '      (trailing junk)')

    def process_server_supported_versions(self, data: bytes) -> None:
        if len(data) != 2:
            self._chunk(data, '      content (invalid)')
            return
        self._chunk(data, '      ' + self._version_name(data[0], data[1]))

    def process_extension(self, is_server: bool, type_: int,
                          length: int, data: bytes) -> None:
        if len(data) < length:
            self._chunk(data, '      content (truncated)')
        elif type_ == 43:
            if is_server:
                self.process_server_supported_versions(data)
            else:
                self.process_client_supported_versions(data)
        else:
            self._chunk(data, '      content')

    def process_extensions(self, is_server: bool, data: bytes) -> int:
        offset = 0
        while offset < len(data):
            if offset + 2 > len(data):
                self._chunk(data[offset:], '    (truncated type)')
                return
            type_ = int.from_bytes(data[offset:offset+2], 'big')
            self._chunk(data[offset:offset+2],
                        '    type=' + self._extension_type_name(type_))
            offset += 2
            if offset + 2 > len(data):
                self._chunk(data[offset:], '      (truncated length)')
                return
            length = int.from_bytes(data[offset:offset+2], 'big')
            self._chunk(data[offset:offset+2], f'      length={length}')
            offset += 2
            self.process_extension(is_server, type_,
                                   length, data[offset:offset+length])
            offset += length

    def process_client_hello(self, content: bytes) -> None:
        self._chunk(content[0:2], '  client_version')
        self._chunk(content[2:34], '  random')
        offset = 34
        if len(content) <= offset:
            return
        offset = self._advance_raw_bytes(content, offset, 1, 'session ID', 2)
        if len(content) <= offset:
            return
        offset = self._advance_cipher_suites(content, offset)
        if len(content) <= offset:
            return
        offset = self._advance_compression_methods(content, offset)
        if len(content) <= offset:
            return
        data, offset = self._advance_bytes(content, offset, 2, 'extensions', 2)
        self.process_extensions(False, data)
        if len(content) <= offset:
            return
        self._chunk(content[offset:], '  trailing data (invalid)')

    @staticmethod
    def _handshake_message_type_name(handshake_message_type: int) -> str:
        return {
            0: 'hello_request',
            1: 'client_hello',
            2: 'server_hello',
            11: 'certificate',
            12: 'server_key_exchange',
            13: 'certificate_request',
            14: 'server_hello_done',
            15: 'certificate_verify',
            16: 'client_key_exchange',
            20: 'finished',
        }.get(handshake_message_type, '(unknown alert description)')

    def process_handshake_message(self, message: bytes) -> None:
        message_type = message[0]
        message_length = int.from_bytes(self.handshake_message[1:4], 'big')
        payload = message[4:]
        if len(payload) < message_length:
            self._chunk(b'', 'Handshake message (partial)')
        else:
            self._chunk(b'', 'Handshake message')
        self._chunk(message[0:1], '  type=' + self._handshake_message_type_name(message_type))
        self._chunk(message[1:4], f'  length={message_length}')
        if message_type == 1:
            self.process_client_hello(message[4:])
        else:
            self._chunk(message[4:], '  content')

    def process_handshake_record(self, payload: bytes) -> None:
        self.handshake_message += payload
        while len(self.handshake_message) >= 4:
            message_length = int.from_bytes(self.handshake_message[1:4], 'big')
            first_length = 4 + message_length
            if len(self.handshake_message) >= first_length:
                first_message = self.handshake_message[:first_length]
                self.process_handshake_message(first_message)
                self.handshake_message = self.handshake_message[first_length:]
            else:
                break

    def process_raw_record(self, payload: bytes) -> None:
        self._chunk(payload, '  data')

    def process_record(self,
                       record_type: int, version_major: int, version_minor: int,
                       record_length: int, payload: bytes) -> None:
        """Explain a TLS record.
        """
        self._chunk(bytes([]), 'TLS record')
        self._chunk(bytes([record_type]),
                    '  type=' + self._record_type_name(record_type))
        self._chunk(bytes([version_major, version_minor]),
                    '  version=' + self._version_name(version_major, version_minor))
        self._chunk_int(record_length, 2, f'  length={record_length}')
        if record_type == 20:
            self.process_change_cipher_spec_record(payload)
        elif record_type == 21:
            self.process_alert_record(payload)
        elif record_type == 22:
            self.process_handshake_record(payload)
        else:
            self.process_raw_record(payload)

    def process_wire(self, data: bytes) -> None:
        """Explain a sequence of TLS records."""
        while data:
            if len(data) < 5:
                print(f'{data.hex()}  Too short for a TLS record (needs 5-byte header)')
                return
            record_header = data[:5]
            (record_type, version_major, version_minor, record_length) = \
                struct.unpack('!BBBH', record_header)
            payload = data[5:5+record_length]
            data = data[5+record_length:]
            self.process_record(record_type, version_major, version_minor,
                                record_length, payload)
        if len(self.handshake_message) >= 4:
            self.process_handshake_message(self.handshake_message)

def main() -> None:
    """Command line entry point."""
    parser = argparse.ArgumentParser()
    parser.add_argument('data', nargs='*',
                        help='Data to explain (hex dump)')
    args = parser.parse_args()
    if args.data:
        for hex_data in args.data:
            data = bytes.fromhex(hex_data)
            Wire().process_wire(data)
    else:
        data = sys.stdin.buffer.read()
        Wire().process_wire(data)

if __name__ == '__main__':
    main()
