#!/usr/bin/env python3

import argparse
import subprocess
import shutil
import itertools
import os
import re
import glob
import sys
import shutil
from collections import namedtuple

ALL_COMPILERS = [ "gcc", "clang", "armclang", "arm-none-eabi-gcc", "iar" ]
NATIVE_TARGET = None

ARCHS    = [ "mips", "mipsel", "mips64", "mips64el", "powerpc64le", "s390x", "riscv64", "x86_64", "x86" ]
ARM_ISAS = [ "thumb1", "thumb2", "arm", "aarch64" ]

KEY_TARGETS = [
    ("armv5-arm", "gcc", "-O0"),
    ("armv6-thumb1", "gcc", "-O0"),
    ("armv6-thumb2", "clang", "-Os"),
    ("armv7-arm", "clang", "-O2"),
    ("armv7-arm", "armclang", "-Os"), # build test only
    ("armv8-thumb2", "clang", "-Os"),
    ("armv8-aarch64", "clang", "-O3"),
    ("mips", "clang", "-Os"), # big-endian 32-bit
    ("mips64", "gcc", "-O2"), # big-endian 64-bit
    ("x86", "gcc", "-O2"),
    ("x86_64", "gcc", "-O2")
]

SIZE_TFM_COMPILER = "armclang"
DEFAULT_COMPILER  = "clang"

# supported non-native compile options
# see https://en.wikipedia.org/wiki/ARM_Cortex-M#Instruction_sets
# and https://en.wikipedia.org/wiki/List_of_ARM_processors
# https://stackoverflow.com/questions/15036909/how-to-list-supported-target-architectures-in-clang/35061913#35061913
# default first (you get the first thing that matches if you specify only half of <arch>-<isa>, e.g. "armv8" or "thumb2")
NON_NATIVE_SUPPORT = {
    "armclang": [ "armv8-thumb2", "armv8-arm", "armv6-thumb1", "armv6-arm", "armv7-thumb2", "armv7-arm", "armv8-aarch64" ],
    "gcc":      [ "armv8-thumb2", "armv8-arm", "armv5-thumb1", "armv5-arm", "armv6-thumb1", "armv6-thumb2", "armv6-arm", "armv7-thumb2", "armv7-arm", "armv8-aarch64" ] + ARCHS,
    "clang":    [ "armv8-thumb2", "armv8-arm", "armv5-thumb1", "armv5-arm", "armv6-thumb1", "armv6-thumb2", "armv6-arm", "armv7-thumb2", "armv7-arm", "armv8-aarch64" ] + ARCHS,
    "iar":      [ "armv8-thumb2", "armv8-arm", "armv5-thumb1", "armv5-arm", "armv6-thumb1", "armv6-thumb2", "armv6-arm", "armv7-thumb2", "armv7-arm", "armv8-aarch64" ]
}

QEMU_NAME_MAP = {
    "powerpc64le": "ppc64le",
    "x86": "i386"
}

MEMSAN_OPTIONS = [ "MBEDTLS_TEST_CONSTANT_FLOW_MEMSAN", "-MBEDTLS_USE_PSA_CRYPTO", "-MBEDTLS_AESNI_C", "-MBEDTLS_AESCE_C" ]
MEMSAN_CFLAGS  = ['-fsanitize=memory', '-O1', '-g3', '-fno-omit-frame-pointer', '-fno-optimize-sibling-calls', '-fsanitize-memory-track-origins=2']
MEMSAN_CC      = "clang"

COMPILER_CONFIGS = {
#    "armclang": [ "MBEDTLS_NO_UDBL_DIVISION" ]
}

ASAN_CFLAGS   = ['-fsanitize=address', '-fno-common', '-fsanitize=undefined', '-fno-sanitize-recover=all', '-O1', '-g3', '-fno-omit-frame-pointer', '-fno-optimize-sibling-calls']
ASAN_LDFLAGS  = ASAN_CFLAGS

WARNING_FLAGS = {
    "iar"  : ['--warnings_are_errors'], # cannot enable --strict because then IAR will not recognise #warning
    "clang": ['-Werror', '-Wall', '-Wextra', '-Wwrite-strings', '-Wpointer-arith', '-Wimplicit-fallthrough', '-Wshadow', '-Wvla', '-Wformat=2', '-Wno-format-nonliteral', '-Wshadow', '-Wasm-operand-widths', '-Wunreachable-code'],
    "gcc"  : ['-Werror', '-Wall', '-Wextra', '-Wwrite-strings', '-Wpointer-arith', '-Wimplicit-fallthrough', '-Wshadow', '-Wvla', '-Wformat=2', '-Wno-format-nonliteral', '-Wshadow', '-Wformat-signedness', '-Wformat-overflow=2', '-Wformat-truncation', '-Wlogical-op']
}
WARNING_FLAGS["arm-none-eabi-gcc"] = WARNING_FLAGS["gcc"]
WARNING_FLAGS["armclang"]          = WARNING_FLAGS["clang"]

# Use full system libraries for IAR
COMPILER_FLAGS = {
    "iar": ["--dlib_config=full"]
}

TFM_TARGET_FLAGS = {
    ("armclang", "armv8-thumb2"): ["-mcpu=cortex-m33+nodsp+nofp", "-mthumb", "--target=arm-arm-none-eabi"],
    ("clang",    "armv8-thumb2"): ["-mcpu=cortex-m33+nodsp+nofp", "-mthumb", "--target=arm-linux-gnueabi"],
    ("gcc",      "armv8-thumb2"): ["-mcpu=cortex-m33+nodsp+nofp", "-mthumb"]
}

TFM_CONFIG_FILES = [("config-tfm.h", None), ("tfm_mbedcrypto_config_profile_medium.h", "crypto_config_profile_medium.h")]
COPY_TFM_CONFIG = "//TFM-CONFIG//"

Target = namedtuple("Target", ["compiler", "compiler_family", "arch", "baremetal", "isa", "arch_isa", "is_native", "arm_arch", "cflags", "ldflags", "config"])


gitresult = subprocess.run(["git", "rev-parse", "--show-toplevel"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
ROOT = gitresult.stdout.decode("utf-8").strip()
if gitresult.returncode != 0 or not os.path.exists(f"{ROOT}/include/mbedtls"):
    ROOT = None # will display help and exit during argument parsing
else:
    # found root, construct the other paths
    TEST_DIR = ROOT + "/tests"

    uname = subprocess.run(["uname", "-m"], stdout=subprocess.PIPE, stderr=subprocess.STDOUT).stdout.decode("utf-8").strip()
    if uname in ["aarch64", "arm64"]:
        NATIVE_TARGET = "armv8-aarch64"
    elif uname in ["x86_64", "amd64"]:
        NATIVE_TARGET = "x86_64"
    else:
        NATIVE_TARGET = uname

    CONFIG_BACKUP        = ROOT + "/include/mbedtls/mbedtls_config.h.mtest_backup"
    CONFIG_FILE          = ROOT + "/include/mbedtls/mbedtls_config.h"
    CRYPTO_CONFIG_BACKUP = ROOT + "/include/psa/crypto_config.h.mtest_backup"
    CRYPTO_CONFIG_FILE   = ROOT + "/include/psa/crypto_config.h"
    if not os.path.exists(CONFIG_FILE):
        # config file not found, assume we are on 2.x
        CONFIG_BACKUP = ROOT + "/include/mbedtls/config.h.mtest_backup"
        CONFIG_FILE   = ROOT + "/include/mbedtls/config.h"
    if not os.path.exists(CRYPTO_CONFIG_FILE):
        CRYPTO_CONFIG_FILE = None


def log(msg=None, indent=0, indent_adjust=0, _indent=[0]):
    _indent[0] += indent_adjust
    if msg is not None:
        for l in msg.splitlines():
            print((" " * (indent + _indent[0])) + l)


def error(msg):
    log(msg, indent=0)
    exit(1)


def subrun(cmd, test_dir=False, silent=False, ignore_failure=False):
    dir = TEST_DIR if test_dir else ROOT
    if not silent:
        r = subprocess.run(cmd, cwd=dir, shell=False)
    else:
        r = subprocess.run(cmd, cwd=dir, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    output = "" if r.stdout is None else r.stdout.decode("utf-8")
    if r.returncode != 0 and not ignore_failure:
        # failure
        log(output)
        print(f"failed: {cmd}")
        exit(r.returncode)
    return (output, r.returncode)


def clean():
    log("make clean")
    subrun(["make", "clean"], silent=True)


def toolchain_exes(target):
    compiler_exe = target.compiler
    archiver_exe = None

    # construct triple needed in gcc and objdump executable name
    triple_abi = "gnu"
    triple_arch = target.arch
    if target.arch == "x86":
        triple_arch = "i686"
    elif target.isa == "aarch64":
        triple_arch = "aarch64"
    elif target.arch.startswith("armv"):
        triple_arch = "arm"
        if target.baremetal:
            triple_abi = "eabi"
        elif target.arm_arch >= 7:
            triple_abi = "gnueabihf"
        else:
            triple_abi = "gnueabi"
    if target.arch in ["mips64", "mips64el"]:
        triple_abi = "gnuabi64"
    if target.baremetal:
        triple = f"{triple_arch}-none-{triple_abi}"
    else:
        triple = f"{triple_arch}-linux-{triple_abi}"

    if target.compiler_family == "gcc":
        if not target.is_native:
            # see https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html
            if "-march" in target.cflags or "-mcpu" in target.cflags:
                # user-specified arch/isa/cpu
                triple = "aarch64-linux-gnu"
                for v in range(1,7):
                    if f"-march=armv{v}" in target.cflags: triple = "arm-linux-gnueabi"
                if "-mthumb" in target.cflags: triple = "arm-linux-gnueabi"
                m = re.search(r"-mcpu=cortex-(\S+)", target.cflags)
                if m:
                    v = m.group(1)
                    if (v[0] == 'a' and int(v[1:]) < 34): triple = "arm-linux-gnueabi"
                    if (v[0] == 'm'): triple = "arm-linux-gnueabi"
                if "-mcpu=arm" in target.cflags: triple = "arm-linux-gnueabi"

            compiler_exe = f"{triple}-{target.compiler}"
        else:
            compiler_exe = target.compiler

        if "-" not in target.compiler:
            # search for versioned compiler, e.g. "gcc-10", if version not already specified by user
            if shutil.which(compiler_exe) is None:
                for i in range(25, 1, -1):
                    c = f"{compiler_exe}-{i}"
                    if shutil.which(c) is not None:
                        compiler_exe = c
                        break

    elif target.compiler_family == "iar":
        compiler_exe = "iccarm"
        archiver_exe = "iarchive"

    if target.compiler == "gcc":
        compiler_error = f"could not locate gcc executable {compiler_exe} or {compiler_exe}-<majorversion>"
    elif target.compiler_family == "gcc":
        compiler_error = f"could not locate gcc executable {compiler_exe}"
    else:
        compiler_error = f"could not locate {target.compiler} executable"
    if shutil.which(compiler_exe) is None:
        compiler_exe = None

    # non-arch-specific size should work in all cases, but may as well prefer <triple>-size
    if args.size:
        size_exe = triple + "-size"
        if shutil.which(size_exe) is None:
            size_exe = "size"
        if shutil.which(size_exe) is None:
            size_exe = None
    else:
        size_exe = None
    size_error = f"could not locate size executable {triple}-size or size"

    # we need an architecture-specific obj-dump for disassembly (unless it's a native build)
    if args.disassemble:
        objdump_exe = triple + "-objdump"
        if shutil.which(objdump_exe) is None:
            if target.is_native:
                objdump_exe = "objdump"
            if shutil.which(objdump_exe) is None:
                objdump_exe = None
    else:
        objdump_exe = None
    if target.is_native:
        objdump_error = f"could not locate size executable {triple}-objdump or objdump"
    else:
        objdump_error = f"could not locate size executable {triple}-objdump"

    if target.arch.startswith("armv"):
        qemu_arch = "arm"
    else:
        qemu_arch = QEMU_NAME_MAP.get(target.arch, target.arch)
    qemu_exe = f"qemu-{qemu_arch}-static"
    qemu_error = f"could not locate qemu executable {qemu_exe}"
    if shutil.which(qemu_exe) is None:
        qemu_exe = None

    return {
        "compiler": compiler_exe,
        "archiver": archiver_exe,
        "objdump": objdump_exe,
        "size": size_exe,
        "triple": triple,
        "qemu": qemu_exe,
        "compiler_error": compiler_error,
        "size_error": size_error,
        "objdump_error": objdump_error,
        "qemu_error": qemu_error
    }


def toolchain(target, exit_on_failure=True):
    # basic CFLAGS setup
    # target_c_flags are options generated by mtest, which may get overridden by the user (and dropped from the resulting set of flags)

    target_c_flags = [f"-I{ROOT}/include"] + COMPILER_FLAGS.get(target.compiler_family, [])

    if target.compiler_family != "iar":
        # IAR defaults to C99 and doesn't have an option for it to be explicitly specified
        target_c_flags += ["-std=c99"]

    if args.size_tfm and "clang" in target.compiler:
        target_c_flags += ["-Oz"]
    elif target.compiler_family == "iar":
        # -Ohz = high optimization, favouring size
        # -Ol = fastest compile time (about 3x better than Ohz)
        target_c_flags += ["-Ol"]
    else:
        target_c_flags += ["-Os"]

    if args.no_warnings:
        if "clang" in target.compiler_family:
            target_c_flags += ["-Wno-everything"]
        elif target.compiler_family == "iar":
            target_c_flags += ["--no_warnings"]
        else:
            target_c_flags += ["-Wno-all", "-Wno-extra"]
    else:
        if target.compiler_family in WARNING_FLAGS:
            target_c_flags += WARNING_FLAGS[target.compiler_family]

    if args.memsan:
        target_c_flags += MEMSAN_CFLAGS
    elif args.asan:
        target_c_flags += ASAN_CFLAGS

    if args.size_tfm and (target.compiler_family, target.arch_isa) in TFM_TARGET_FLAGS:
        # Preset flags to get reference target for TF-M size builds
        target_c_flags += TFM_TARGET_FLAGS[(target.compiler_family, target.arch_isa)]
    else:
        if target.compiler == "armclang":
            if target.arch == "armv6" and target.isa == "thumb1":
                # strictly speaking, includes "some 32-bit Thumb2 instructions" but this is the oldest ISA armclang supports
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-m0", "-mthumb"]
            elif target.arch == "armv6" and target.isa == "arm":
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-m0", "-marm"]
            elif target.arch == "armv7" and target.isa == "thumb2":
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-m3", "-mthumb"]
            elif target.arch == "armv7" and target.isa == "arm":
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-a17", "-marm"]
            elif target.arch == "armv8" and target.isa == "thumb2":
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-m33+dsp", "-mthumb"]
            elif target.arch == "armv8" and target.isa == "arm":
                target_c_flags += ["--target=arm-arm-none-eabi", "-mcpu=cortex-a72", "-marm"]
            elif target.arch == "armv8" and target.isa == "aarch64":
                target_c_flags += ["--target=aarch64-arm-none-eabi", "-mcpu=cortex-a78"]
            else:
                if exit_on_failure: error(f"unsupported ISA {target.isa} for armclang")

        elif target.compiler_family == "gcc":
            if not target.is_native:
                # see https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html
                if not ("-march" in target.cflags or "-mcpu" in target.cflags):
                    # not user-specified arch/isa/cpu
                    if target.arch == "armv5" and target.isa == "thumb1":
                        target_c_flags += ["-mcpu=arm926ej-s", "-mthumb"]
                    elif target.arch == "armv5" and target.isa == "arm":
                        target_c_flags += ["-march=armv5te", "-marm"]
                    elif target.arch == "armv6" and target.isa == "thumb1":
                        target_c_flags += ["-mcpu=arm1136jf-s", "-mthumb"]
                    elif target.arch == "armv6" and target.isa == "thumb2":
                        target_c_flags += ["-mcpu=arm1156t2-s", "-mthumb"]
                    elif target.arch == "armv6" and target.isa == "arm":
                        target_c_flags += ["-mcpu=arm1136jf-s", "-marm"]
                    elif target.arch == "armv7" and target.isa == "thumb2":
                        target_c_flags += ["-mcpu=cortex-a17", "-mthumb"]
                    elif target.arch == "armv7" and target.isa == "arm":
                        target_c_flags += ["-march=armv7-a+simd", "-marm"]
                    elif target.arch == "armv8" and target.isa == "thumb2":
                        target_c_flags += ["-mcpu=cortex-a32+crypto", "-mthumb"]
                    elif target.arch == "armv8" and target.isa == "arm":
                        target_c_flags += ["-mcpu=cortex-a32+crypto", "-marm"]
                    elif target.arch == "armv8" and target.isa == "aarch64":
                        target_c_flags += ["-mcpu=cortex-a78", "-march=armv8.2-a+simd+crypto"]
                    elif target.arch.startswith("armv"):
                        target_c_flags += ["-march=" + target.arch]
                if target.arch in {"x86", "x86_64"}:
                    # Support AESNI intrinsics
                    target_c_flags += ["-mpclmul", "-msse2", "-maes"]

        elif target.compiler_family == "clang":
            if not target.is_native:
                # non-native clang build
                if target.arch == "armv5" and target.isa == "thumb1":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-mcpu=arm926ej-s", "-mthumb"]
                elif target.arch == "armv5" and target.isa == "arm":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-march=armv5te", "-marm"]
                elif target.arch == "armv6" and target.isa == "thumb1":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-mcpu=arm1136j-s", "-mthumb"]
                elif target.arch == "armv6" and target.isa == "thumb2":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-mcpu=arm1156t2-s", "-mthumb"]
                elif target.arch == "armv6" and target.isa == "arm":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-march=armv6", "-marm"]
                elif target.arch == "armv7" and target.isa == "thumb2":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-mcpu=cortex-a17", "-mthumb"]
                elif target.arch == "armv7" and target.isa == "arm":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-march=armv7-a", "-marm"]
                elif target.arch == "armv8" and target.isa == "thumb2":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-mcpu=cortex-a32", "-mthumb"]
                elif target.arch == "armv8" and target.isa == "arm":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-march=armv8-a", "-marm"]
                elif target.arch == "armv8" and target.isa == "aarch64":
                    target_c_flags += ["--target=arm-linux-gnueabihf", "-march=armv8-a", "-maarch64"]
                elif target.arch.startswith("mips") and "64" in target.arch:
                    target_c_flags += [f"--target={target.arch}-linux-gnuabi64"]
                elif target.arch == "x86":
                    target_c_flags += ["--target=i686-linux-gnu", "-mpclmul", "-msse2", "-maes"]
                elif target.arch == "x86_64":
                    target_c_flags += ["--target=x86_64-linux-gnu", "-mpclmul", "-msse2", "-maes"]
                elif target.arch in ["mips", "mipsel", "powerpc64le", "s390x", "riscv64"]:
                    target_c_flags += [f"--target={target.arch}-linux-gnu"]
                else:
                    error(f"unsupported target {target.arch} {target.isa} for clang")

        elif target.compiler_family == "iar":
            if target.arch == "armv5" and target.isa == "thumb1":
                target_c_flags += ["--cpu=ARM926EJ-S", "--thumb"]
            elif target.arch == "armv5" and target.isa == "arm":
                target_c_flags += ["--cpu=ARM968E-S", "--arm"]
            elif target.arch == "armv6" and target.isa == "thumb1":
                target_c_flags += ["--cpu=ARM1136J-S", "--thumb"]
            elif target.arch == "armv6" and target.isa == "thumb2":
                target_c_flags += ["--cpu=ARM1156T2-S", "--thumb"]
            elif target.arch == "armv6" and target.isa == "arm":
                target_c_flags += ["--cpu=ARM1156T2-S", "--arm"]
            elif target.arch == "armv7" and target.isa == "thumb2":
                target_c_flags += ["--cpu=Cortex-A17", "--thumb"]
            elif target.arch == "armv7" and target.isa == "arm":
                target_c_flags += ["--cpu=Cortex-A17", "--arm"]
            elif target.arch == "armv8" and target.isa == "thumb2":
                target_c_flags += ["--cpu=Cortex-A32", "--thumb"]
            elif target.arch == "armv8" and target.isa == "arm":
                target_c_flags += ["--cpu=Cortex-A32", "--arm"]
            elif target.arch == "armv8" and target.isa == "aarch64":
                target_c_flags += ["--cpu=Cortex-A72", "--aarch64"]

    # unconditionally add user-specified flags
    c_flags = target.cflags.split(" ")

    # add each CFLAG for target only if not user-specified
    for f in reversed(target_c_flags):
        if '=' in f:
            # option like -mstd=c99
            o, v = f.split("=")
            if any(x.startswith(f"{o}=") for x in c_flags):
                continue
        elif f.startswith("-O"):
            # special case for -Os, -Oz, etc
            if any([x.startswith("-O") for x in c_flags]):
                continue
        elif f in ["-mthumb", "-marm"]:
            # special case for Arm ISA selection
            if not {"-mthumb", "-marm"}.isdisjoint(c_flags):
                continue
        else:
            # binary options like e.g. "-maes", "-fno-lto", "-Wxyz"
            # check that neither e.g. "-mXYZ" nor "-mno-XYZ" is present before adding it
            if len(f) > 5 and f[2:5] == "no-":
                o = {f[:2] + f[5:], f}
            else:
                o = {f, f[:2] + "no-" + f[2:]}
            if not o.isdisjoint(c_flags): continue
        # not already present: put at start so it should be over-ridden if the above missed something
        c_flags = [f] + c_flags

    ld_flags = target.ldflags
    if args.asan:
        ld_flags = ld_flags + " " + " ".join(ASAN_LDFLAGS)
    if not target.is_native:
        ld_flags += " --static"

    if target.compiler_family == "iar":
        # Specify AR_FLAGS for IAR
        ar_flags = "--create"
    else:
        # Do not specify AR_FLAGS - the Makefile will generate some IAR-incompatible flags
        ar_flags = None

    exes = toolchain_exes(target)
    return {
        "CFLAGS": " ".join(x for x in c_flags if x != "").strip(),
        "LDFLAGS": ld_flags.strip(),
        "ARFLAGS": ar_flags,
        "CC": exes["compiler"],
        "AR": exes["archiver"],
        "OBJDUMP": exes["objdump"],
        "SIZE": exes["size"]
    }


def backup_config_options(restore, delete_backup):
    if restore:
        # restore backup
        shutil.copy(CONFIG_BACKUP, CONFIG_FILE)
        if CRYPTO_CONFIG_FILE is not None: shutil.copy(CRYPTO_CONFIG_BACKUP, CRYPTO_CONFIG_FILE)
        if delete_backup:
            os.remove(CONFIG_BACKUP)
            os.remove(CRYPTO_CONFIG_BACKUP)
    else:
        # make a backup
        shutil.copy(CONFIG_FILE, CONFIG_BACKUP)
        if CRYPTO_CONFIG_FILE is not None: shutil.copy(CRYPTO_CONFIG_FILE, CRYPTO_CONFIG_BACKUP)


def set_config_option(action, option, silent=True):
    force = [ "--force" ] if action == "set" else []
    if option.startswith("PSA_WANT"):
        if not silent:
            log(f"scripts/config.py -f {CRYPTO_CONFIG_FILE} {action} {option} {'1' if action == 'set' else ''}")
        if action == "set":
            output, success = subrun([f"{ROOT}/scripts/config.py"] + force + ["--file", CRYPTO_CONFIG_FILE, action, option, "1"], silent=True, ignore_failure=True)
        else:
            output, success = subrun([f"{ROOT}/scripts/config.py"] + force + ["--file", CRYPTO_CONFIG_FILE, action, option], silent=True, ignore_failure=True)
    else:
        if not silent:
            log(f"scripts/config.py {action} {option}")
        output, success = subrun([f"{ROOT}/scripts/config.py"] + force + [action, option], silent=True, ignore_failure=True)
    if success != 0:
        error(output)


def configure_options(target):
    # gather up required options:
    # target-specific options
    options = target.config
    # compiler-specific options
    options += COMPILER_CONFIGS.get(target.compiler_family, [])
    # memsan options
    if args.memsan:
        options += MEMSAN_OPTIONS
    # user-specified options to apply to all targets
    options += args.config_options

    set_no_platform_entropy = False
    disable_spm = False

    individual_options = [x for x in options if x.startswith("MBEDTLS_") or x.startswith("-MBEDTLS_") or x.startswith("PSA_") or x.startswith("-PSA_")]
    bulk_options = [x for x in options if x not in individual_options]

    for config in bulk_options:
        if config == COPY_TFM_CONFIG:
            # older versions of this config file need SPM to be disabled
            disable_spm = True
            # special flag to copy both TF-M config files - these have a couple of possible locations
            for mc, cc in TFM_CONFIG_FILES:
                if os.path.exists(f"{ROOT}/configs/{mc}") and (cc is None or os.path.exists(f"{ROOT}/configs/{cc}")):
                    if mc == TFM_CONFIG_FILES[0][0]:
                        # latest TF-M config file unsets this, so set it again
                        set_no_platform_entropy = True
                        disable_spm = False # not needed with latest version
                    for c, dest in zip([mc, cc], [CONFIG_FILE, CRYPTO_CONFIG_FILE]):
                        if c is not None:
                            log(f"cp configs/{c} {dest[len(ROOT) + 1:]}")
                            shutil.copy(f"{ROOT}/configs/{c}", dest)
                    break
            else:
                # for looking at old checkouts where these configs were not in the tree, fetch from
                # date they were first created instead
                for config, dest in zip(TFM_CONFIG_FILES[-1], [CONFIG_FILE, CRYPTO_CONFIG_FILE]):
                    log(f"git show 2f1ae5a86ebd67faa50c3983b4567656c2234674:configs/{config} > {dest[len(ROOT) + 1:]}")
                    output, _ = subrun(["git", "show", "origin/development:configs/" + config], silent=True)
                    with open(dest, 'w') as f:
                        f.write(output)
        elif config.endswith(".h"):
            # a config file - overwrite existing config file
            path = config if os.path.exists(config) else f"{ROOT}/configs/{config}"
            if path.split("/")[-1].startswith("crypto_config_"):
                dest = CRYPTO_CONFIG_FILE
            else:
                dest = CONFIG_FILE
            log(f"cp {path[len(ROOT) + 1:] if path.startswith(ROOT) else path} {dest[len(ROOT) + 1:]}")
            shutil.copy(path, dest)
        else:
            # a configuration recognised by config.py, e.g. "baremetal"
            log(f"scripts/config.py {config}")
            subrun([f"{ROOT}/scripts/config.py", config], silent=True)

    if disable_spm:
        # at some point in the past, MBEDTLS_HAVE_ASM also needs disabling,
        # and more options again (not sure which) for 3.0.0
        set_config_option("unset", "MBEDTLS_PSA_CRYPTO_SPM", silent=False)
    if set_no_platform_entropy:
        # this gets disabled by #8164 - ensure it is set
        set_config_option("set", "MBEDTLS_NO_PLATFORM_ENTROPY", silent=False)

    for config in individual_options:
        # an individual option like MBEDTLS_XYZ or -PSA_XYZ
        action = "set"
        if config.startswith("-"):
            action = "unset"
            config = config[1:]
        set_config_option(action, config, silent=False)


def flags_to_hr_str(flags):
    hrs = ""
    for f in flags:
        if '=' in f:
            l, r = f.split("=", 1)
            if " " in r: r = "\"" + r + "\""
            hrs += f" {l}={r}"
        else:
            hrs += f" {f}"
    return hrs.strip()


def can_disassemble(target):
    return toolchain_exes(target)["objdump"] is not None


def disassemble(target):
    # note: clang seems to want "-gdwarf-4" passed to CFLAGS to show source with --source properly
    # run objdump -d to disassemble
    objdump = toolchain(target)["OBJDUMP"]
    objfiles = ["library/libmbedcrypto.a", "library/libmbedtls.a", "library/libmbedx509.a" ] + args.build_targets
    objfiles = [f"{ROOT}/{f}" for f in objfiles if os.path.exists(f"{ROOT}/{f}")]
    result = []
    for fn in args.disassemble:
        if fn is None:
            disarg = "--disassemble"
        else:
            disarg = f"--disassemble={fn}"
        output, _ = subrun([objdump] + objfiles + [disarg, "--visualize-jumps=extended-color"], silent=True)
        if fn is None:
            result.append(output)
        else:
            # extract the relevant bit of output
            found = False
            diss = []
            for l in output.splitlines():
                if l.strip().endswith(f"{fn}>:"):
                    found = True
                if found and re.search(r"[\w_]+.o:\s+file format", l): break
                if found and l.strip().startswith("Disassembly of section"): break
                if found: diss.append(l)
            if not found:
                result.append(f"<{fn}>:    function not found - maybe the function gets inlined?")
            else:
                while len(diss) > 0 and diss[-1] == "": diss = diss[:-1]
                result.append("\n".join(diss))
    return "\n\n".join(result)


def can_build(target):
    return toolchain_exes(target)["compiler"] is not None


def build(target, tests):
    log("building")
    try:
        log(indent_adjust=4)
        if not args.no_clean:
            clean()
        t = toolchain(target)

        flags = ["CFLAGS=" + t['CFLAGS'], "CC=" + t['CC']]

        if target.compiler_family == "iar":
            # Clear WARNING_CFLAGS so that the Makefile doesn't automatically add -Wall etc, which IAR doesn't understand
            flags += ["WARNING_CFLAGS="]

        if t['LDFLAGS'] != "":
            flags += ["LDFLAGS=" + t['LDFLAGS']]

        if t['AR'] is not None:
            flags += ['AR=' + t['AR']]

        if t['ARFLAGS'] is not None:
            flags += ['ARFLAGS=' + t['ARFLAGS']]

        configure_options(target)

        if args.jobs is None:
            make_cmd = ["make"]
            make_log = "make"
        else:
            if args.jobs == -1: args.jobs=""
            make_cmd = ["make", f"-j{args.jobs}"]
            make_log = f"make -j{args.jobs}"

        if args.build_targets:
            bts = args.build_targets
        else:
            bts = ["lib"]
        log(f'{make_log} {" ".join(bts)} {flags_to_hr_str(flags)}')
        subrun(make_cmd + bts + flags, silent=True)

        if args.tests:
            log(f"{make_log} -C {TEST_DIR} {' '.join(tests)} {flags_to_hr_str(flags)}")
            subrun(make_cmd + tests + flags, test_dir=True, silent=True)

        if args.tests:
            log(subrun(["file", tests[0]], test_dir=True, silent=True)[0].strip())
        log("ok")
    finally:
        log(indent_adjust=-4)


def can_size(target):
    return toolchain_exes(target)["size"] is not None


def size(target):
    log("size")
    try:
        log(indent_adjust=4)
        t = toolchain(target)
        if args.build_targets:
            size_target = args.build_targets[0]
        else:
            size_target = "library/libmbedcrypto.a"
        log(f'{t["SIZE"]} {size_target}')
        size = subrun([t["SIZE"], size_target], silent=True)[0]
        lines = size.splitlines()
        # sort modules by text+data size
        lines = lines[:1] + sorted(lines[1:], key=lambda l:int(l.split()[0]) + int(l.split()[1]))
        for l in lines:
            # skip modules with zero size
            if not re.search(r"^\s*0\s+0\s+0\s+0\s+0\s", l): log(l)
        size_data = [x.split()[0:3] for x in size.splitlines()[1:]]
        text_sum = sum(int(x[0]) for x in size_data)
        data_sum = sum(int(x[1]) for x in size_data)
        log(f"total text = {text_sum}")
        log(f"total data = {data_sum}")
        log(f"total text + data (i.e., binary size) = {text_sum + data_sum}")
    finally:
        log(indent_adjust=-4)


def can_run(target):
    if target.is_native:
        return True
    else:
        return toolchain_exes(target)["qemu"] is not None


def run(target, tests, quiet=False):
    if target.baremetal or not tests: return

    log("running")
    try:
        log(indent_adjust=4)
        for t in tests:
            log(f"running {t} on {target.arch_isa}")
            if target.is_native:
                output, _ = subrun(f"{TEST_DIR}/" + t, test_dir=True, silent=quiet)
            else:
                qemu_exe = toolchain_exes(target)["qemu"]
                output, _ = subrun([qemu_exe, t], test_dir=True, silent=quiet)
            if quiet and output:
                log(output.splitlines()[-1])
    finally:
        log(indent_adjust=-4)


def get_supported_configs():
    # parse the output of "config.py -h" to get options like "baremetal_size", etc
    s = subrun(["scripts/config.py", "-h"], silent=True)[0].splitlines()
    s = [s[i] for i in range(0, len(s)) if "Commands:" in s[:i]]
    s = [x[:24].split()[0] for x in s if len(s) >= 24 and len(x[:24].strip()) > 0]
    s = [x for x in s if x not in ["get", "set", "set-all", "unset", "unset-all"] and "," not in x]
    # get the list of config files
    config_files = [x for x in os.listdir(f'{ROOT}/configs') if x.endswith(".h")]
    return s + config_files


def parse_args():
    DESCRIPTION = '''mtest drives the Mbed TLS build and test tooling with cross-compilation support.
In order to support other architectures, it expects cross-compile tools and qemu installed.
It can be run from anywhere in an Mbed TLS checkout.
'''

    EPILOG_TEXT = '''
 
EXAMPLE USAGE
=============

Build the library:
mtest

Build with modified configuration:
mtest MBEDTLS_CIPHER_MODE_XTS -MBEDTLS_CIPHER_MODE_CTR   # enable XTS, and disable CTR
mtest config-thread                                      # use "configs/config-thread.h"
mtest baremetal                                          # use baremetal preset from config.py
mtest baremetal -MBEDTLS_CIPHER_MODE_CBC                 # baremetal, with CBC disabled

Test sha functions under ASAN:
mtest shax -A

Build and run all the aes tests, with clang and gcc, with MBEDTLS_AESCE_C set and MBEDTLS_AESNI_C unset:
mtest '*aes*' clang gcc  MBEDTLS_AESCE_C -MBEDTLS_AESNI_C

Build and run the base64 tests, for armv6-thumb1, aarch64 and x86_64:
mtest base64 armv6-thumb1 aarch64 x86_64

Run alignment test suite on key targets:
mtest -k alignment

Report library size, as built by armclang -Oz with TF-M configuration for armv8 thumb2:
mtest -S
mtest -S clang-16                             # as above, but use clang-16 instead of the default armclang
mtest -S MBEDTLS_P256M_EXAMPLE_DRIVER_ENABLED # as above, but modify TF-M config with given option(s)

Build aes.o multiple times, with every combination of the given options:
mtest aes.o MBEDTLS_AES_SETKEY_ENC_ALT,MBEDTLS_AES_DECRYPT_ALT,MBEDTLS_AES_ROM_TABLES,MBEDTLS_AES_ENCRYPT_ALT,MBEDTLS_AES_SETKEY_DEC_ALT,MBEDTLS_AES_FEWER_TABLES,MBEDTLS_PADLOCK_C

Disassemble cmac.o:
mtest cmac.o -d

Disassemble mbedtls_xor for arm, built with gcc-12 -Os:
mtest -d mbedtls_xor -Os gcc-12 arm
'''

    REST_HELP = f'''Optional list of tests, compilers, flags, architectures, config options and build targets.
Tests: e.g. test_suite_ccm ccm 'cipher*' '*aes*'
Recognised compilers: {", ".join(ALL_COMPILERS)}, gcc-10, clang-12, ..., or specify with e.g. mtest CC=gcc
Flags: anything starting with a '-' will get passed to CFLAGS if not recognised by mtest
    (e.g. -O0 gets passed through), or specify CFLAGS with e.g.: mtest CFLAGS="-Wunused"
Architectures: {", ".join(ARM_ISAS)}, armv5, ..., armv8 or e.g. armv7-thumb2
    {", ".join(ARCHS)}
Config options: individual options are set with e.g. MBEDTLS_AESCE_C, or unset with e.g. -PSA_WANT_ALG_MD5.
    Options recognised by scripts/config.py are permitted (e.g. "baremetal").
    Passing a file from configs/ (e.g. "config-tfm") or any ".h" file will replace the existing config file.
    Iterate over the cross-product of options X,Y,Z by specifying a comma-separated list of config options.
    The original config files will be restored when mtest exits.
Build targets: build the library by default, or files (e.g. aes.o), programs (e.g. selftest) or tests (as above)'''

    parser = argparse.ArgumentParser(description=DESCRIPTION, epilog=EPILOG_TEXT, formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('-k', '--key-archs', action="store_true", default=False, help='build/test on key targets, including all four combinations of 32/64-bit and big/little endian')
    parser.add_argument('-M', '--memsan', action="store_true", default=False, help="make a MEMSAN build (clang native only)")
    parser.add_argument('-A', '--asan', action="store_true", default=False, help="make an ASAN build")
    parser.add_argument('-W', '--no-warnings', action="store_true", default=False, help="disable warnings")
    parser.add_argument('-C', '--no-clean', action="store_true", default=False, help="don't run make clean (if building for a single target)")
    parser.add_argument('-d', '--disassemble', metavar='function', action='append', nargs='?', help="disassemble specified function(s) or file(s) (or everything if no function/file specified)")
    parser.add_argument('-s', '--size', action="store_true", default=False, help="display size of library / given build target")
    parser.add_argument('-S', '--size-tfm', action="store_true", default=False, help=f"as --size, but use the TF-M config file and build with {SIZE_TFM_COMPILER} -Oz for Cortex-M33")
    parser.add_argument('-j', '--jobs', nargs='?', const=-1, metavar='N', action="store", type=int, help="enable parallel builds, like 'make -j'. Alternatively, set the MAKEFLAGS environment variable")
    parser.add_argument('rest', metavar='args', nargs='*', help=REST_HELP)

    # handle -MBEDTLS_OPTION style args manually because they confuse argparse w.r.t. -M for --memsan
    raw_args = [x for x in sys.argv if not x.startswith("-MBEDTLS_") and not (len(x) > 2 and x.startswith("-W"))][1:]
    args, unknown_args = parser.parse_known_intermixed_args(raw_args)
    args.rest += unknown_args

    # invocation was not 'mtest -h' (handled above by argparse), so error if not in a checkout
    if ROOT is None:
        print("couldn't find root of Mbed TLS checkout (must run from within an Mbed TLS checkout)")
        exit(1)

    # extract compilers
    args.compilers = [x[3:].strip() for x in args.rest if x.startswith("CC=")]
    for x in list(args.rest):
        if x in ALL_COMPILERS or x.startswith("clang-") or x.startswith("gcc-"):
            args.compilers.append(x)
            args.rest.remove(x)

    ldflags = " ".join([x[8:].strip() for x in args.rest if x.startswith("LDFLAGS=")])
    cflags  = " ".join([x[7:].strip() for x in args.rest if x.startswith("CFLAGS=")])
    # assume any unknown args, i.e. anything starting with a "-" is to be passed to the compiler via CFLAGS
    cflags += " " + " ".join([x for x in args.rest if x.startswith("-") and not x.startswith("-MBEDTLS_") and not x.startswith("-PSA_WANT_")])
    cflags += " ".join([x for x in sys.argv if x.startswith("-W") and len(x) > 2])

    # extract config options
    args.config_options  = [x for x in args.rest if x.startswith("MBEDTLS_") or x.startswith("PSA_WANT_") or x.startswith("-PSA_WANT_")]
    args.config_options += [x for x in sys.argv if x.startswith("-MBEDTLS_")]

    # generate cross-product of options like "X,Y,Z" -> [(X,Y,Z),(X,Y,-Z), ..., (-X,-Y,-Z)]
    options_with_comma = [x for x in args.config_options if "," in x]
    if options_with_comma:
        # extract raw list for generating cross-product (discard leading hyphens)
        options_with_comma = set(x[1:] if x.startswith("-") else x for x in ",".join(options_with_comma).split(','))
        args.config_options     = [x for x in args.config_options if "," not in x]
        # generate cross-product
        dash_combinations = itertools.product(["", "-"], repeat=len(options_with_comma))
        configs_xprod = [[dash + option for dash, option in zip(dashes, options_with_comma)] for dashes in dash_combinations]
    else:
        configs_xprod = [[]]

    # identify required config files (either directly specified, or implied by -S)
    supported_configs = get_supported_configs()
    config = []
    if args.size_tfm:
        config.append("MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH")
        config.append("MBEDTLS_PSA_P256M_DRIVER_ENABLED")
        config.append("-PSA_WANT_ALG_DETERMINISTIC_ECDSA")
        config.append("-PSA_WANT_KEY_TYPE_ECC_KEY_PAIR_DERIVE")
        config.append(COPY_TFM_CONFIG)
    for a in list(args.rest):
        if a.endswith(".h") and os.path.exists(a):
            # arbitrary .h file
            config.append(a)
            args.rest.remove(a)
            continue
        x = a.split("/")[-1] if "configs/" in a else a
        if x in supported_configs or f"{x}.h" in supported_configs:
            # file in configs directory, or a known argument to set_config.py
            config.append(f"{x}.h" if f"{x}.h" in supported_configs else x)
            args.rest.remove(a)
            continue

    # filter out non-config options, and non-flags
    args.rest = [x for x in args.rest if not x.startswith("-") and not x.startswith("MBEDTLS_") and not x.startswith("PSA_WANT_")]
    args.rest = [x for x in args.rest if not x.startswith("CFLAGS=") and not x.startswith("LDFLAGS=") and not x.startswith("CC=")]

    # find any things in programs to build
    all_programs = [x[len(ROOT)+1:-2] for x in glob.glob(f'{ROOT}/programs/**/*.c', recursive=True)]
    args.build_targets = []
    for x in list(args.rest):
        found = [p for p in all_programs if p.endswith("/" + x)]
        if found:
            args.build_targets += found
            args.rest.remove(x)

    # extract any specified architectures
    args.archs = []
    for x in list(args.rest):
        a = None
        if x.startswith("armv"):
            if "-" in x:
                a = x
            else:
                a = x + "-"
        elif x in ARCHS:
            a = x
        elif x in ARM_ISAS:
            a = "-" + x
        if a is not None:
            args.archs.append(a)
            args.rest.remove(x)
    if not args.archs:
        if args.size_tfm:
            args.archs = [ "armv8-thumb2" ]
        else:
            args.archs = [ NATIVE_TARGET ]

    if args.memsan:
        if len(args.archs) > 1 or (len(args.archs) == 1 and args.archs[0] != NATIVE_TARGET): error("cannot specify non-native arch with --memsan")
        if len(args.compilers) > 1 or (len(args.compilers) == 1 and args.compilers[0] != "clang"): error("cannot specify compilers with --memsan")
        args.compilers = [ MEMSAN_CC ]

    if args.size_tfm:
        if not args.compilers:
            if shutil.which(SIZE_TFM_COMPILER) is not None:
                args.compilers = [ SIZE_TFM_COMPILER ]
            else:
                print("warning: could not find armclang, falling back to clang")
                args.compilers = [ "clang" ]
        args.size = True

    if not args.compilers:
        args.compilers = [ DEFAULT_COMPILER ]

    # identify things to build
    tests = []
    for t in args.rest:
        if t.endswith(".o") or t.endswith(".a"):
            args.build_targets.append("library/" + t)
        else:
            if "*" in t:
                if not t.startswith("*"): t = "*" + t
                if not t.endswith("*"): t = t + "*"
                new_tests = [x.split("/")[-1][:-5] for x in glob.glob(TEST_DIR + "/suites/" + t) if x.endswith(".data")]
                tests += new_tests
            else:
                if not t.startswith("test_suite"):
                    t = "test_suite_" + t
                if not os.path.exists(f"{TEST_DIR}/suites/{t}.data"):
                    all_tests = "    " + "\n    ".join([x[11:-5] for x in sorted(os.listdir(f"{TEST_DIR}/suites")) if x.endswith(".data")])
                    error(f"Test {t} not found; available tests are:\n{all_tests}")
                tests += [t]
    args.tests = tests

    # construct list of targets to build for
    args.targets = []
    for config_xprod in configs_xprod:
        if args.key_archs:
            for arch, c, cf in KEY_TARGETS:
                if "-" in arch:
                    a, i = arch.split("-")
                else:
                    a, i = arch, None
                arm_arch_v = int(a[4]) if a.startswith("armv") else 0
                baremetal = c in [ "armclang", "iar" ] or "-none-" in c
                if len(config) == 0 and baremetal:
                    target_config = [ "baremetal" ]
                else:
                    target_config = config[:]
                target_config += config_xprod
                t = Target(compiler=c, compiler_family=c, arch=a, baremetal=baremetal, isa=i,
                           arch_isa=arch, is_native=arch == NATIVE_TARGET,
                            arm_arch=arm_arch_v, cflags=cf, ldflags=ldflags, config=target_config)
                args.targets.append(t)
        else:
            for c, arch in itertools.product(args.compilers, args.archs):
                if "-" in arch:
                    a, i = arch.split("-")
                else:
                    a, i = arch, None

                # determine if combo is valid for non-native compilers
                if c.startswith("clang-"):
                    compiler_family = "clang"
                elif c.startswith("gcc-"):
                    compiler_family = "gcc"
                else:
                    compiler_family = c
                if arch != NATIVE_TARGET:
                    for x in NON_NATIVE_SUPPORT.get(compiler_family, []):
                        if "-" in x:
                            sa, si = x.split("-")
                            if (a == "" or a == sa) and (i == "" or i == si):
                                a = sa
                                i = si
                                arch = a + "-" + i
                                break
                        else:
                            if x == arch:
                                a = x
                                i = None
                                break
                    else:
                        # could not find supported compiler
                        error(f"don't know how to set target flags for compiler {c}")

                arm_arch_v = int(a[4]) if a.startswith("armv") else 0
                baremetal = c in [ "armclang", "iar" ] or "-none-" in c or args.size_tfm
                if len(config) == 0 and baremetal:
                    target_config = [ "baremetal" ]
                else:
                    target_config = config[:]
                target_config += config_xprod
                t = Target(compiler=c, compiler_family=compiler_family, arch=a, baremetal=baremetal,
                           isa=i, arch_isa=arch, is_native=arch == NATIVE_TARGET,
                           arm_arch=arm_arch_v, cflags=cflags, ldflags=ldflags, config=target_config)
                args.targets.append(t)
    if not args.targets:
        error("no valid targets specified")
    args.targets.sort(key=lambda t: t.arch + str(t.isa) + t.compiler)

    if len(args.targets) > 1 and args.no_clean:
        error("cannot specify --no-clean with multiple targets")

    return args


def main():
    quiet = len(args.targets) > 1 or len(args.tests) > 1
    backup_config_options(restore=False, delete_backup=False)

    try:
        for target in args.targets:
            if target.compiler in ALL_COMPILERS:
                log(f"{target.arch_isa} {target.compiler}", indent=0)
            else:
                log(f"{target.compiler}", indent=0)
            try:
                log(indent_adjust=4)
                backup_config_options(restore=True, delete_backup=False)
                if can_build(target):
                    build(target, args.tests)
                else:
                    log("skipping target: " + toolchain_exes(target)["compiler_error"])
                    continue
                if args.size:
                    if can_size(target):
                        size(target)
                    else:
                        log("skipping size: " + toolchain_exes(target)["size_error"])
                if args.disassemble is not None:
                    if can_disassemble(target):
                        d = disassemble(target)
                        log(f"Disassembly:")
                        print(d)
                        print()
                    else:
                        log("skipping disassemble: " + toolchain_exes(target)["objdump_error"])
                if args.tests:
                    if can_run(target):
                        run(target, args.tests, quiet=quiet)
                    else:
                        log("skipping running tests: " + toolchain_exes(target)["qemu_error"])
            finally:
                log("\n", indent=0)
                log(indent_adjust=-4)
    finally:
        backup_config_options(restore=True, delete_backup=True)

args = parse_args()
main()
