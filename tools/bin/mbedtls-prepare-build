#!/usr/bin/env python3
"""Generate a makefile for Mbed Crypto or Mbed TLS.
"""

import abc
import argparse
import collections
import enum
import glob
import itertools
import os
import platform
import re
import shutil
import subprocess
import sys
import tempfile
import typing
from typing import Dict, Iterable, List, Optional, Set, Tuple


T = typing.TypeVar('T')
V = typing.TypeVar('V')

# The typing_extensions module is necessary for type annotations that are
# checked with mypy. It is only used for type annotations or to define
# things that are themselves only used for type annotations. It is not
# available on a default Python <3.8 installation. Therefore, try loading
# what we need from it for the sake of mypy (which depends on, or comes
# with, typing_extensions), and if not define substitutes that lack the
# static type information but are good enough at runtime.
try:
    from typing_extensions import Protocol #pylint: disable=import-error
except ImportError:
    class Protocol: #type: ignore
        #pylint: disable=too-few-public-methods
        pass

class Writable(Protocol):
    """Abstract class for typing hints."""
    # pylint: disable=no-self-use,too-few-public-methods,unused-argument
    def write(self, text: str) -> typing.Any:
        ...


def sjoin(*args: str) -> str:
    """Join the arguments (strings) with a single space between each."""
    return ' '.join(args)

def append_to_value(d: Dict[T, List[V]],
                    key: T, *values: V) -> None:
    """Append to a value in a dictionary.

    Append values to d[key]. Create an empty list if d[key] does not exist.
    """
    lst = d.setdefault(key, [])
    lst += values

def are_same_existing_files(*files: str) -> bool:
    """Whether all the given files are the same file.

    Symbolic links are considered the same as their target.
    Non-existent paths are not considered the same as anything, even themselves.
    """
    for file1 in files:
        if not os.path.exists(file1):
            return False
    for file1 in files[1:]:
        if not os.path.samefile(files[0], file1):
            return False
    return True

class EnvironmentOption:
    """A description of options that set makefile variables.

    Such an option has the following fields:
    * var: the variable name (e.g. 'FOO_BAR').
    * option: the command line option for this script (e.g. '--foo-bar').
    * attr: the attribute name in the options object.
    * help: help text for the option and the variable.
    * default: a default value if the variable is not in the environment.
    """

    def __init__(self, var: str, default='',
                 help: Optional[str] = None,
                 option: Optional[str] = None) -> None:
        self.var = var
        self.attr = var
        self.option = ('--' + var.lower().replace('_', '-')
                       if option is None else option)
        self.default = default
        self.help = help

DEFAULT_LDFLAGS_L_DLOPEN = (
    '-ldl' if platform.system() == 'Linux' else
    '')

"""A list of makefile variables that can be set through command line options.
"""
_environment_options = [
    EnvironmentOption('AR', 'ar',
                      'Archive building tool'),
    EnvironmentOption('ARFLAGS', '-src',
                      'Options to pass to ${AR} (e.g. "rcs")'),
    EnvironmentOption('CC', 'cc',
                      'C compiler'),
    EnvironmentOption('CP', 'cp',
                      'Program to copy files (e.g. "cp")'),
    EnvironmentOption('CFLAGS', '-Os',
                      'Options to always pass to ${CC} when compiling'),
    EnvironmentOption('COMMON_FLAGS', '',
                      'Options to always pass to ${CC} when compiling or linking'),
    EnvironmentOption('DLLFLAGS', '-shared',
                      'Options to pass to ${CC} when building a shared library'),
    EnvironmentOption('EXTRA_LIBS', '',
                      'Extra libraries to link programs (including tests) with'),
    EnvironmentOption('LDFLAGS', '',
                      'Options to always pass to ${CC} when linking'),
    EnvironmentOption('LDFLAGS_L_DLOPEN', DEFAULT_LDFLAGS_L_DLOPEN,
                      'Options to pass to ${CC} when linking a program that calls dlopen()'),
    EnvironmentOption('LDFLAGS_L_THREADS', '-lpthread',
                      'Options to pass to ${CC} when linking a program that uses threads'),
    EnvironmentOption('LIBRARY_EXTRA_CFLAGS', '',
                      'Options to pass to ${CC} when compiling library sources'),
    EnvironmentOption('PERL', 'perl',
                      'Perl interpreter'),
    EnvironmentOption('PROGRAMS_EXTRA_CFLAGS', '',
                      'Options to pass to ${CC} when compiling sample programs'),
    EnvironmentOption('PROGRAMS_EXTRA_LDFLAGS', '',
                      'Options to pass to ${CC} when linking sample programs'),
    EnvironmentOption('PYTHON', 'python3',
                      'Python3 interpreter'),
    EnvironmentOption('QEMU_LD_PREFIX', '',
                      'Path to a runtime for Qemu'),
    EnvironmentOption('RM', 'rm -f',
                      'Program to remove files (e.g. "rm -f")'),
    EnvironmentOption('RUN', '',
                      'Command prefix before executable programs'),
    EnvironmentOption('RUNS', '',
                      'Command suffix after executable programs'),
    EnvironmentOption('TESTS_EXTRA_CFLAGS', '',
                      'Options to pass to ${CC} when compiling unit tests'),
    EnvironmentOption('TESTS_EXTRA_LDFLAGS', '',
                      'Options to pass to ${CC} when linking unit tests'),
    EnvironmentOption('VALGRIND', 'valgrind',
                      'Path to valgrind'),
    EnvironmentOption('VALGRIND_FLAGS', sjoin('-q',
                                              '--tool=memcheck',
                                              '--leak-check=yes',
                                              '--show-reachable=yes',
                                              '--num-callers=50'),
                      'Options to pass to ${VALGRIND}'),
    EnvironmentOption('WARNING_CFLAGS', '-Wall -Wextra -Werror',
                      'Options to always pass to ${CC}'),
]


# For typing purposes. To be refined.
Options = argparse.Namespace


"""The list of potential submodules.

A submodule is a subdirectory of the source tree which has the same
general structure as the source tree.
"""
SUBMODULE_NAMES = ['crypto']


class SourceFile:
    """A description of a file path in the source tree.

    Each file path is broken down into three parts: the root of the source
    tree, the path to the submodule (the empty string for files that are
    not in a submodule), and the path inside the submodule.
    """

    def __init__(self, root: str, submodule: str, inner_path: str) -> None:
        self.root = root
        self.submodule = submodule
        self.inner_path = inner_path

    def sort_key(self) -> Tuple[str, bool, str]:
        # Compare by inner path first, then by submodule.
        # The empty submodule comes last.
        return (self.inner_path,
                not self.submodule, self.submodule)

    def __lt__(self, other: 'SourceFile') -> bool:
        if self.root != other.root:
            raise TypeError("Cannot compare source files under different roots"
                            , self, other)
        return self.sort_key() < other.sort_key()

    def relative_path(self) -> str:
        """Path to the file from the root of the source tree."""
        return os.path.join(self.submodule, self.inner_path)

    def source_dir(self) -> str:
        """Path to the directory containing the file, from the root of the
        source tree."""
        return os.path.dirname(self.relative_path())

    def real_path(self) -> str:
        """A path at which the file can be opened during makefile generation."""
        return os.path.join(self.root, self.submodule, self.inner_path)

    def make_path(self) -> str:
        """A path to the file that is valid in the makefile."""
        if self.submodule:
            return '/'.join(['$(SOURCE_DIR)', self.submodule, self.inner_path])
        else:
            return '$(SOURCE_DIR)/' + self.inner_path

    def target_dir(self) -> str:
        """The target directory for build products of this source file.

        This is the path to the directory containing the source file
        inside the submodule.
        """
        return os.path.dirname(self.inner_path)

    def base(self) -> str:
        """The path to the file inside the submodule, without the extension."""
        return os.path.splitext(self.inner_path)[0]

    def target(self, extension) -> str:
        """A build target for this source file, with the specified extension."""
        return self.base() + extension

class GeneratedFile(SourceFile):
    """A generated file which can be used as an intermediate source file.

    These objects behave like SourceFile objects, but they designate a file
    inside the build tree rather than a file inside the source tree.
    """

    def __init__(self, path: str) -> None:
        super().__init__('.', '', path)

    def make_path(self) -> str:
        return self.inner_path


class TestGeneratorInterface:
    """Test generator script description interface."""

    __metaclass__ = abc.ABCMeta

    @abc.abstractmethod
    def target(self, c_file: str) -> str:
        """A space-separated list of generated files."""
        ...

    @abc.abstractmethod
    def script(self, source_dir: str) -> str:
        """The path to the generator script."""
        ...

    @abc.abstractmethod
    def function_files(self, function_file: str) -> List[str]:
        """The full list of .function files used to generate the given suite.

        This always includes the argument, and can include other files
        (helpers.function, etc.).
        """
        ...

    @abc.abstractmethod
    def command(self, function_file: str, data_file: str) -> str:
        """The build command to generate the given test suite."""
        ...

class ClassicTestGenerator(TestGeneratorInterface):
    """Test generator script description for the classic (<<2.13) test generator
    (generate_code.pl)."""

    def __init__(self, options: Options) -> None:
        self.options = options

    @staticmethod
    def target(c_file: str) -> str:
        return c_file

    @staticmethod
    def script(_source_dir: str) -> str:
        return 'tests/scripts/generate_code.pl'

    @staticmethod
    def function_files(function_file: str) -> List[str]:
        return ['tests/suites/helpers.function',
                'tests/suites/main_test.function',
                function_file]

    @staticmethod
    def command(function_file: str, data_file: str) -> str:
        source_dir = os.path.dirname(function_file)
        if source_dir != os.path.dirname(data_file):
            raise Exception('Function file and data file are not in the same directory',
                            function_file, data_file)
        if not function_file.endswith('.function'):
            raise Exception('Function file does not have the .function extension',
                            function_file)
        if not data_file.endswith('.data'):
            raise Exception('Data file does not have the .data extension',
                            data_file)
        return sjoin('$(PERL)',
                     '$(SOURCE_DIR_FROM_TESTS)/tests/scripts/generate_code.pl',
                     '$(SOURCE_DIR_FROM_TESTS)/tests/suites',
                     os.path.splitext(os.path.basename(function_file))[0],
                     os.path.splitext(os.path.basename(data_file))[0])

class OnTargetTestGenerator(TestGeneratorInterface):
    """Test generator script description for the >=2.13 test generator
    with on-target testing support (generate_test_code.py)."""

    def __init__(self, options: Options) -> None:
        self.options = options

    @staticmethod
    def target(c_file: str) -> str:
        datax_file = os.path.splitext(c_file)[0] + '.datax'
        return sjoin(c_file, datax_file)

    @staticmethod
    def script(source_dir: str) -> str:
        return os.path.dirname(source_dir) + '/scripts/generate_test_code.py'

    @staticmethod
    def function_files(function_file: str, on_target=False) -> List[str]:
        source_dir = os.path.dirname(function_file)
        return (['{}/{}.function'.format(source_dir, helper)
                 for helper in ['helpers', 'main_test',
                                'target_test' if on_target else 'host_test']] +
                [function_file])

    @classmethod
    def command(cls, function_file: str, data_file: str) -> str:
        source_dir = os.path.dirname(function_file)
        suite_path = '$(SOURCE_DIR_FROM_TESTS)/' + source_dir
        return sjoin('$(PYTHON)',
                     '$(SOURCE_DIR_FROM_TESTS)/' + cls.script(source_dir),
                     '-f $(SOURCE_DIR_FROM_TESTS)/' + function_file,
                     '-d $(SOURCE_DIR_FROM_TESTS)/' + data_file,
                     '-t', suite_path + '/main_test.function',
                     '-p', suite_path + '/host_test.function',
                     '--helpers-file', suite_path + '/helpers.function',
                     '-s', suite_path,
                     '-o .')

class MakefileMaker:
    """A class to generate a makefile for Mbed TLS or Mbed Crypto.

    Typical usage:
        MakefileMaker(options, source_path).generate()
    """

    PSA_CRYPTO_DRIVER_WRAPPERS_DEPENDENCIES = frozenset([
        'include/psa/crypto_driver_common.h',
        'include/psa/crypto_platform.h',
        'include/psa/crypto_types.h',
        'include/psa/crypto_values.h',
        'library/psa_crypto_core.h',
        'library/psa_crypto_driver_wrappers.h',
    ])

    @staticmethod
    def gather_submodules(source_dir) -> Iterable[str]:
        """Iterate over the existing submodules under source_dir.

        3rdparty directories are considered submodules, as well as
        names registered in SUBMODULE_NAMES.
        """
        for m in SUBMODULE_NAMES:
            if os.path.isdir(os.path.join(source_dir, m)):
                yield m
        for d in glob.glob(os.path.join(source_dir, '3rdparty', '*')):
            continue #TODO
            if os.path.isdir(os.path.join(d, 'include')) or \
               os.path.isdir(os.path.join(d, 'library')) or \
               os.path.isdir(os.path.join(d, 'programs')) or \
               os.path.isdir(os.path.join(d, 'tests')):
                yield d[len(source_dir)+1:]

    def __init__(self, options: Options, source_path: str) -> None:
        """Initialize a makefile generator.

        options is the command line option object.

        source_path is a path to the root of the source directory,
        relative to the root of the build directory.
        """
        self.options = options
        if self.options.indirect_extensions:
            self.executable_extension = '$(EXEXT)'
            self.library_extension = '$(LIBEXT)'
            self.assembly_extension = '$(ASMEXT)'
            self.object_extension = '$(OBJEXT)'
            self.shared_library_extension = '$(DLEXT)'
        else:
            self.executable_extension = self.options.executable_extension
            self.library_extension = self.options.library_extension
            self.assembly_extension = self.options.assembly_extension
            self.object_extension = self.options.object_extension
            self.shared_library_extension = self.options.shared_library_extension
        self.source_path = source_path
        self.out = None #type: Optional[Writable]
        self.static_libraries = None #type: Optional[List[str]]
        self.help = {} #type: Dict[str, str] # target: help_text
        self.clean = [] #type: List[str] # file names or patterns to clean
        self.variables_to_export = set() #type: Set[str]
        if options.QEMU_LD_PREFIX:
            self.variables_to_export.add('QEMU_LD_PREFIX')
        self.dependency_cache = {
            # TODO: arrange to find dependencies of this generated file.
            # They're hard-coded for now, but that won't work if the
            # dependencies change over time.
            'library/psa_crypto_driver_wrappers.c': self.PSA_CRYPTO_DRIVER_WRAPPERS_DEPENDENCIES,
        }
        self.submodules = list(self.gather_submodules(self.options.source))
        if self.source_exists('tests/scripts/generate_test_code.py'):
            self.test_generator = OnTargetTestGenerator(options) #type: TestGeneratorInterface
        else:
            self.test_generator = ClassicTestGenerator(options)
        # Unset fields that are only meaningful at certain later times.
        # Setting them here makes Pylint happy, but having set them here
        # makes it harder to diagnose if some method is buggy and attempts
        # to use a field whose value isn't actually known.
        # (TODO: this was back before mypy. Now it's probably simpler to
        # allow None, since mypy forces to assert 'is not None' explicitly?)
        del self.static_libraries # Set when generating the library targets
        del self.out # Set only while writing the output file

    def get_file_submodule(self, filename: str) -> Tuple[Optional[str], str]:
        """Break up a path into submodule and inner path.

        More precisely, given a path filename from the root of the source
        tree, return a tuple (submodule, inner_path) where submodule
        is the submodule containing the file and inner_path is the path
        to the file inside the submodule. If the file is not in a submodule,
        return None for the submodule.
        """
        # This function and the ones that use it should be rewritten
        # to work on SourceFile objects.
        for submodule in self.submodules:
            if filename.startswith(submodule + os.sep):
                return submodule, filename[len(submodule) + 1:]
        return None, filename

    def crypto_file_path(self, filename: str) -> str:
        """Return the path to a crypto file.

        Look for the file at the given path in the crypto submodule, and if
        it exists, return its path from the root of the source tree.
        Otherwise return filename unchanged.
        """
        in_crypto = os.path.join('crypto', filename)
        if os.path.exists(in_crypto):
            filename = in_crypto
        return '$(SOURCE_DIR)/' + filename

    def source_exists(self, filename: str) -> bool:
        """Test if the given path exists in the source tree.

        This function does not try different submodules. If the file is
        in a submodule, filename must include the submodule part.
        """
        return os.path.exists(os.path.join(self.options.source, filename))

    def line(self, text: str) -> None:
        """Emit a makefile line."""
        assert self.out is not None
        self.out.write(text + '\n')

    def words(self, *words: str) -> None:
        """Emit a makefile line obtain by joining the words with spaces."""
        self.line(' '.join(words))

    def assign(self, name: str, *value_words: str) -> None:
        """Emit a makefile line that contains an assignment.

        The assignment is to the variable called name, and its value
        is value_words joined with spaces as the separator.
        """
        nonempty_words = [word for word in value_words if word]
        self.line(' '.join([name, '='] + nonempty_words))

    # TODO: what should be the type of format? Mypy can check format strings
    # since https://github.com/python/mypy/pull/7418, but how do I indicate
    # that template is a formatting template?
    def format(self, template, *args):
        """Emit a makefile line containing the given formatted template."""
        self.line(template.format(*args))

    def comment(self, template, *args):
        """Emit a makefile comment line containing the given formatted template."""
        self.format('## ' + template, *args)

    def add_dependencies(self, name: str, *dependencies: str) -> None:
        """Generate dependencies for name."""
        parts = (name + ':',) + dependencies
        simple = ' '.join(parts)
        if len(simple) < 80:
            self.line(simple)
        else:
            self.line(' \\\n\t\t'.join(parts))

    _glob2re_re = re.compile(r'[.^$*+?{}\|()]')
    @staticmethod
    def _glob2re_repl(m: typing.Match[str]) -> str:
        if m.group(0) == '*':
            return '[^/]*'
        elif m.group(0) == '?':
            return '[^/]'
        else:
            return '\\' + m.group(0)
    @classmethod
    def glob2re(cls, pattern: str) -> str:
        # Simple glob pattern to regex translator. Does not support
        # character sets properly, which is ok because we don't use them.
        # We don't use fnmatch or PurePath.match because they let
        # '*' and '?' match '/'.
        return re.sub(cls._glob2re_re, cls._glob2re_repl, pattern)

    def is_already_cleaned(self, name: str) -> bool:
        if not self.clean:
            return False
        regex = ''.join(['\A(?:',
                         '|'.join([self.glob2re(pattern)
                                   for patterns in self.clean
                                   for pattern in patterns.split()]),
                         ')\Z'])
        return re.match(regex, name) is not None

    def add_clean(self, *elements: str) -> None:
        """Add one or more element to the list of things to clean.

        These can be file paths or wildcard patterns. They can contain
        macro expansions.

        Elements that are added in the same call to this function are grouped
        together for cosmetic purposes.
        """
        self.clean.append(' '.join(elements))

    def target(self, name: str, dependencies: Iterable[str],
               commands: Iterable[str],
               help: Optional[str] = None,
               phony=False,
               clean: Optional[bool] = None,
               short: Optional[str] = None) -> None:
        """Generate a makefile rule.

        * name: the target(s) of the rule. This is a string. If there are
          multiple targets, separate them with spaces.
        * dependencies: a list of dependencies.
        * commands: a list of commands to run (the recipe).
        * help: documentation to show for this target in "make help".
          If this is omitted, the target is not listed in "make help".
        * phony: if true, declare this target as phony.
        * clean: if true, add this target to the list of things to clean.
          This parameter only has an effect on non-phony targets.
          By default, add this target to the list of things to clean unless
          it's already there, possibly via a wildcard pattern.
        * short: if this is specified, the command(s) in the recipe
          will not be shown in the make transcript, and instead the
          make transcript will display this string.
        """
        self.add_dependencies(name, *dependencies)
        if short:
            self.format('\t@$(ECHO_IF_QUIET) "  {}"', short)
        for com in commands:
            self.format('\t{}{}',
                        ('' if short is None else '$(Q)'),
                        com.strip('\n').replace('\n', ' \\\n\t'))
        if help is not None:
            self.help[name] = help
        if phony:
            self.format('.PHONY: {}', name)
        else:
            if clean is None:
                # TODO: is_already_cleaned is slow, and only works as intended
                # if the pattern is added before the specific item, which
                # isn't very natural. Maybe instead I should do an elimination
                # pass at the end, to remove redundant entries. Or maybe
                # just don't worry about it: the only purpose is to avoid
                # having "rm foo.bar" if there's also "rm *.bar", and that's
                # cosmetic.
                clean = True #not self.is_already_cleaned(name)
            if clean:
                self.add_clean(name)

    def setenv_command(self) -> str:
        """Generate a shell command to export some environment variables.

        The values of these variables must not contain the character ``'``
        (single quote).

        Return an empty string if there are no variables to export.
        """
        if not self.variables_to_export:
            return ''
        return (' export ' +
                ' '.join(['{}=\'$({})\''.format(name, name)
                          for name in sorted(self.variables_to_export)]) +
                '; ')

    def environment_option_subsection(self) -> None:
        """Generate the assignments to customizable options."""
        self.comment('Tool settings')
        for envopt in _environment_options:
            if envopt.help is not None:
                self.comment('{}', envopt.help)
            self.assign(envopt.var,
                        getattr(self.options, envopt.attr))

    def settings_section(self) -> None:
        """Generate assignments to customizable and internal variables.

        Some additional section-specified variables are assigned in each
        section.
        """
        if self.options.var:
            self.comment('Auxiliary variables')
            for var in self.options.var:
                if '=' in var:
                    self.line(re.sub(r'\s*([:?+]?=)\s*', ' \1 ', var))
                else:
                    value = os.getenv(var)
                    if value is None:
                        raise KeyError(var)
                    self.format('{} = {}', var, value)
            self.line('')
        self.comment('Path settings')
        self.assign('SOURCE_DIR', self.source_path)
        self.line('')
        self.environment_option_subsection()
        self.line('')
        self.comment('Configuration')
        if self.options.indirect_extensions:
            self.line('ASMEXT = ' + self.options.assembly_extension)
            self.line('OBJEXT = ' + self.options.object_extension)
            self.line('LIBEXT = ' + self.options.library_extension)
            self.line('DLEXT = ' + self.options.shared_library_extension)
            self.line('EXEXT =' + self.options.executable_extension)
        self.line('')
        self.comment('Internal variables')
        self.line('AUX_ECHO_IF_QUIET_ = :')
        self.line('AUX_Q_ =')
        self.line('AUX_ECHO_IF_QUIET_$(V) = echo')
        self.line('AUX_Q_$(V) = @')
        self.line('ECHO_IF_QUIET = $(AUX_ECHO_IF_QUIET_)')
        self.line('Q = $(AUX_Q_)')
        self.assign('SETENV', self.setenv_command())
        self.line('')
        self.comment('Auxiliary paths')
        self.assign('SOURCE_DIR_FROM_TESTS', '../$(SOURCE_DIR)')
        self.assign('VALGRIND_LOG_DIR_FROM_TESTS', '.')

    def include_path(self, filename: str) -> List[str]:
        """Return the include path for filename.

        filename must be a path relative to the root of the source tree.

        Return a list of directories relative to the root of the source tree.
        """
        dirs = []
        submodule, base = self.get_file_submodule(filename)
        subdirs = ['include', 'include/mbedtls', 'library']
        if base.startswith('tests') or base.startswith('programs'):
            subdirs.append('tests')
            if self.source_exists('tests/include'):
                subdirs.append('tests/include')
        for subdir in subdirs:
            if submodule is None:
                dirs += [os.path.join(submodule, subdir)
                         for submodule in self.submodules]
            dirs.append(subdir)
            if submodule is not None:
                dirs.append(os.path.join(submodule, subdir))
            if submodule == '3rdparty/everest':
                dirs.append(os.path.join(submodule, 'include/everest'))
                if '/kremlib/' in filename:
                    dirs.append(os.path.join(submodule, 'include/everest/kremlib'))
                print(filename, dirs)
        return dirs

    def include_path_options(self, filename: str) -> str:
        """Return the include path options (-I ...) for filename."""
        return ' '.join(['-I $(SOURCE_DIR)/' + dir
                         for dir in self.include_path(filename)])

    def collect_c_dependencies(self, c_file: str,
                               stack=frozenset()) -> typing.FrozenSet[str]:
        """Find the build dependencies of the specified C source file.

        c_file must be an existing C file in the source tree.
        Return a set of directory paths from the root of the source tree.

        The dependencies of a C source files are the files mentioned
        in an #include directive that are present in the source tree,
        as well as dependencies of dependencies recursively.
        This function does not consider which preprocessor symbols
        might be defined: it bases its analysis solely on the textual
        presence of "#include".

        This function uses a cache internally, so repeated calls with
        the same argument return almost instantly.

        The optional argument stack is only used for recursive calls
        to prevent infinite loops.
        """
        if c_file in self.dependency_cache:
            return self.dependency_cache[c_file]
        if c_file in stack:
            return frozenset()
        stack |= {c_file}
        include_path = ([os.path.dirname(c_file)] + self.include_path(c_file))
        dependencies = set()
        extra = set()
        with open(os.path.join(self.options.source, c_file)) as stream:
            for line in stream:
                m = re.match(r' *# *include *["<](.*?)[">]', line)
                if m is None:
                    continue
                filename = m.group(1)
                for subdir in include_path:
                    if os.path.exists(os.path.join(self.options.source,
                                                   subdir, filename)):
                        dependencies.add('/'.join([subdir, filename]))
                        break
                else:
                    if filename.endswith('.c'):
                        extra.add(os.path.dirname(c_file) + '/' + filename)
        for dep in frozenset(dependencies):
            dependencies |= self.collect_c_dependencies(dep, stack)
        dependencies |= extra
        frozen = frozenset(dependencies)
        self.dependency_cache[c_file] = frozen
        return frozen

    def is_generated(self, filename: str) -> bool:
        """Whether the specified C file is generated.

        Implemented with heuristics based on the name.

        This does not include configuration-independent files pre-generated
        before the build.
        """
        if 'ssl_debug_helpers_generated.' in filename:
            return False
        if 'value_names_generated' in filename:
            return False
        if '_generated.' in filename:
            return True
        if 'psa_crypto_driver_wrappers.c' in filename:
            # TODO: not in the preliminary work, but upcoming
            return False
            #return True
        return False

    def is_include_only(self, filename: str) -> bool:
        """Whether the specified C file is only meant for use in "#include" directive.

        Implemented with heuristics based on the name.
        """
        return os.path.basename(filename) in {
            'psa_constant_names_generated.c',
            'ssl_test_common_source.c',
        }

    def c_with_dependencies(self, c_file: str) -> List[str]:
        """A list of C dependencies in makefile syntax.

        Generate the depdendencies of c_file with collect_c_dependencies,
        and make it into a list where each file name is given without
        the submodule part if any.

        c_file itself is included in the resulting list.
        """
        # Bug: if xxx_generated.c is present in the source directory,
        # it gets used instead of the one generated in the build directory.
        deps = self.collect_c_dependencies(c_file)
        return [(self.get_file_submodule(filename)[1]
                 if self.is_generated(filename) else
                 '$(SOURCE_DIR)/' + filename)
                for filename in sorted(deps) + [c_file]]

    def c_dependencies_only(self, c_files: Iterable[str]) -> List[str]:
        """A list of C dependencies in makefile syntax.

        Generate the depdendencies of each element of c_files with
        collect_c_dependencies, and make it into a list where each file name
        is given without the submodule part if any.

        The elements of c_files themselves are included not in the resulting
        list unless they are a dependency of another element.
        """
        deps = frozenset.union(*[self.collect_c_dependencies(c_file)
                                 for c_file in c_files])
        return ['$(SOURCE_DIR)/' + filename for filename in sorted(deps)]

    def object_target(self, section: str,
                      src: SourceFile,
                      deps: Iterable[str] = (),
                      auto_deps: bool = True,
                      extra_flags: str = '') -> None:
        c_path = src.make_path()
        dependencies = list(deps)
        if auto_deps:
            dependencies += self.c_with_dependencies(src.relative_path())
        else:
            dependencies += [c_path]
        for short, switch, extension in [
                ('CC -S ', '-S', self.assembly_extension),
                ('CC    ', '-c', self.object_extension),
        ]:
            self.target(src.target(extension),
                        dependencies,
                        [sjoin('$(CC)',
                               '$(WARNING_CFLAGS)',
                               '$(COMMON_FLAGS)',
                               '$(CFLAGS)',
                               ' '.join(['$({}_CFLAGS)'.format(section)]),
                               # TODO: some files need extra -I (currently:
                               # 3rdparty/everest/library/**/*.c need
                               # 3rdparty/everest/include/everst and some
                               # need .../kremlib as well). This is currently
                               # handled in the include_path method, but
                               # we don't call it here, only for a section
                               # as a whole.
                               extra_flags.strip(),
                               '-o $@',
                               switch, c_path)],
                        short=(short + c_path))

    class Library(enum.Enum):
        CRYPTO = 1
        X509 = 2
        TLS = 3

        def __lt__(self, other: 'MakefileMaker.Library') -> bool:
            return self.value < other.value

        def core(self) -> str:
            return self.name.lower()

        def libname(self) -> str:
            return 'libmbed' + self.core()

        # For tracing when a library is accidentally implicitly converted to a string
        def __str__(self):
            import pdb; pdb.set_trace()
            return super().__str__()

    @classmethod
    def library_of(cls, module: str) -> Library:
        """Identify which Mbed TLS library contains the specified module.

        This function bases the result on known module names, defaulting
        to crypto.
        """
        module = os.path.basename(module)
        if module.startswith('x509') or \
           module in ['certs', 'pkcs7', 'pkcs11']:
            return cls.Library.X509
        elif module.startswith('ssl') or \
             module in ['debug', 'net', 'net_sockets']:
            return cls.Library.TLS
        else:
            return cls.Library.CRYPTO

    @classmethod
    def dash_l_lib(cls, lib: typing.Union[Library, str]) -> str:
        """Return the -l option to link with the specified library."""
        if isinstance(lib, cls.Library):
            base = lib.libname()
        else:
            base = os.path.splitext(os.path.basename(lib))[0]
        if base.startswith('lib'):
            base = base[3:]
        return '-l' + base

    def psa_crypto_driver_wrappers_subsection(
            self,
            contents: Dict[Library, List[str]]
    ) -> None:
        generated = 'library/psa_crypto_driver_wrappers.c'
        script_path = self.crypto_file_path('scripts/psa_crypto_driver_wrappers.py')
        sources = [self.crypto_file_path(drv)
                   for drv in self.options.psa_driver]
        contents[self.Library.CRYPTO].append(os.path.splitext(generated)[0])
        self.target(generated,
                    [script_path] + sources,
                    [sjoin(script_path, '-o $@', *sources)])
        self.object_target('LIBRARY', GeneratedFile(generated))

    def list_source_files(self,
                          root: str,
                          *patterns: str) -> Iterable[SourceFile]:
        """List the source files matching any of the specified patterns.

        Look for the specified wildcard pattern under all submodules, including
        the root tree. If a given file name is present in multiple submodules,
        only the earliest matching submodule is kept, with the root tree being
        looked up last.

        This function returns a sorted list of SourceFile objects.
        """
        # FIXME: for error.c at least, we need the root, not the submodule.
        all_sources = {}
        for submodule in self.submodules + ['']:
            submodule_root = os.path.join(root, submodule)
            start = len(submodule_root)
            if submodule:
                start += 1
            sources = []
            for pattern in patterns:
                abs_pattern = os.path.join(submodule_root, pattern)
                sources += [src[start:] for src in glob.glob(abs_pattern)]
            for source_name in sources:
                src = SourceFile(root, submodule, source_name)
                base = src.base()
                # Skip .c files that are only meant to be #include'd
                # in other files, and can't be compiled on their own.
                if self.is_include_only(src.relative_path()):
                    continue
                # Skip files that were seen in an earlier submodule.
                if base not in all_sources:
                    all_sources[base] = src
        return sorted(all_sources.values())

    def library_section(self) -> None:
        """Generate the section of the makefile for the library directory.

        The targets are object files for library modules and
        static and dynamic library files.
        """
        self.comment('Library targets')
        self.assign('LIBRARY_CFLAGS',
                    '-I include/mbedtls', # must come first, for the config header
                    '-I include',
                    self.include_path_options('library/*'),
                    '$(LIBRARY_EXTRA_CFLAGS)')
        self.add_clean(*['library/*' + ext
                         for ext in (self.assembly_extension,
                                     self.library_extension,
                                     self.object_extension,
                                     self.shared_library_extension)])
        # Enumerate modules and emit the rules to build them
        modules = self.list_source_files(self.options.source, 'library/*.c')
        for module in modules:
            self.object_target('LIBRARY', module)
        contents = collections.defaultdict(list)
        # Enumerate libraries and the rules to build them
        for module in modules:
            contents[self.library_of(module.base())].append(module.base())
        if self.options.psa_driver:
            self.psa_crypto_driver_wrappers_subsection(contents)
        libraries = sorted(contents.keys())
        for lib in libraries:
            libname = lib.libname()
            self.format('{}_modules = {}', libname, ' '.join(contents[lib]))
            self.format('{}_objects = $({}_modules:={})',
                        libname, libname, self.object_extension)
        self.static_libraries = []
        shared_libraries = []
        for idx, lib in enumerate(libraries):
            libname = lib.libname()
            objects = '$({}_objects)'.format(libname)
            static = 'library/{}{}'.format(libname, self.library_extension)
            shared = 'library/{}{}'.format(libname, self.shared_library_extension)
            self.static_libraries.append(static)
            shared_libraries.append(shared)
            self.target(static, [objects],
                        ['$(AR) $(ARFLAGS) $@ ' + objects],
                        short='AR    $@')
            dependent_libraries = libraries[:idx]
            if dependent_libraries:
                dash_l_dependent = ('-L . ' +
                                 sjoin(*[self.dash_l_lib(dep)
                                         for dep in dependent_libraries]))
            else:
                dash_l_dependent = ''
            self.target(shared, [objects] + ['library/{}{}'
                                             .format(dep.libname(),
                                                     self.shared_library_extension)
                                             for dep in dependent_libraries],
                        [sjoin('$(CC)',
                               '$(WARNING_CFLAGS)',
                               '$(COMMON_FLAGS)',
                               '$(LDFLAGS)',
                               '$(DLLFLAGS)',
                               '-o $@',
                               dash_l_dependent,
                               objects)],
                        short='LD    $@')
        self.target('lib', self.static_libraries,
                    [],
                    help='Build the static libraries.',
                    phony=True)
        self.target('dll', shared_libraries,
                    [],
                    help='Build the shared libraries.',
                    phony=True)

    _query_config = [
        'programs/ssl/query_config', # in Mbed TLS up to 2.21
        'programs/test/query_config', # in Mbed Crypto
    ]
    _ssl_test_lib = ['programs/ssl/ssl_test_lib']
    """Auxiliary files used by sample programs.

    This is a map from the base of the file containing the main()
    function of the sample program to the list of bases of other
    source files to link into the program. The base of a file
    is the subdirectory path without the submodule part and the
    basename of the file. Non-existing files are ignored.
    """
    _auxiliary_objects = {
        'programs/ssl/ssl_client2': _query_config + _ssl_test_lib,
        'programs/ssl/ssl_server2': _query_config + _ssl_test_lib,
        'programs/test/query_compile_time_config': _query_config,
    }
    """List of bases of source files that are an auxiliary object for
    some sample program.
    """
    _auxiliary_sources = (frozenset(obj
                                    for objs in _auxiliary_objects.values()
                                    for obj in objs)
                          .union({
                              'programs/fuzz/common', 'programs/fuzz/onefile',
                          }))

    def auxiliary_objects(self, base: str) -> Iterable[str]:
        if base.startswith('programs/fuzz'):
            return ['programs/fuzz/common', 'programs/fuzz/onefile']
        else:
            return self._auxiliary_objects.get(base, [])

    def program_libraries(self, app: str) -> List[Library]:
        """Return the list of libraries that app uses.

        app is the base of the main file of a sample program (directory
        without the submodule part and basename of the file).

        Return the list of library base names in their dependency order
        (e.g. ["crypto", "x509", "tls"]).
        """
        basename = os.path.basename(app)
        subdir = os.path.basename(os.path.dirname(app))
        if basename == 'dlopen':
            return []
        if (subdir == 'ssl' or basename.startswith('ssl') or
            subdir == 'fuzz' or
            basename in {'cert_app', 'dh_client', 'dh_server', 'udp_proxy'}
        ):
            return [self.Library.CRYPTO, self.Library.X509, self.Library.TLS]
        if (subdir == 'x509' or
            (basename == 'selftest' and self.source_exists('library/x509.c'))
        ):
            return [self.Library.CRYPTO, self.Library.X509]
        return [self.Library.CRYPTO]

    def extra_link_flags(self, app: str) -> Iterable[str]:
        """Return the list of extra link flags for app.

        app is the base of the main file of a sample program (directory
        without the submodule part and basename of the file).

        Return a list of strings to insert on the command line when
        linking app.
        """
        flags = []
        if 'thread' in app:
            flags.append('$(LDFLAGS_L_THREADS)')
        if 'dlopen' in app:
            flags.append('$(LDFLAGS_L_DLOPEN)')
        if 'zeroize' in app:
            flags.append('-g3')
        return flags

    def add_run_target(self, program: str,
                       executable: Optional[str] = None) -> None:
        if executable is None:
            executable = program + self.executable_extension
        self.target(program + '.run',
                    [executable],
                    ['$(SETENV)$(RUN) ' + executable + ' $(RUNS)'],
                    phony=True)
        self.target(program + '.gmon',
                    [executable],
                    ['$(SETENV)$(RUN) ' + executable + ' $(RUNS)',
                     'mv gmon.out $@'])

    def program_subsection(self, src: SourceFile,
                           executables: List[str]) -> None:
        """Emit the makefile rules for the given sample program.

        src is a SourceFile object refering to a source file under programs/.
        This can either be a file containing a main function or an
        auxiliary source file.

        This function appends the path to the program executable to
        the list executables, unless src refers to an auxiliary file.
        """
        base = src.base()
        if os.path.basename(base) == 'psa_constant_names':
            script_path = self.crypto_file_path('scripts/generate_psa_constants.py')
            self.target(base + '_generated.c',
                        ([script_path] +
                         [self.crypto_file_path(
                             os.path.join('include', 'psa', filename)
                          )
                          for filename in ['crypto_extra.h',
                                           'crypto_values.h']]),
                        [script_path],
                        short='Gen   $@')
            self.add_clean(base + '_generated.c')
        extra_flags = '-I ' + src.target_dir() # for generated files
        if 'zeroize' in base:
            extra_flags += ' -g3'
        object_file = src.target(self.object_extension)
        self.object_target('PROGRAMS', src, extra_flags=extra_flags)
        if base in self._auxiliary_sources:
            return
        exe_file = src.target(self.executable_extension)
        object_deps = [dep + self.object_extension
                       for dep in self.auxiliary_objects(base)
                       if self.source_exists(dep + '.c')]
        libs = list(reversed(self.program_libraries(base)))
        lib_files = ['library/{}{}'.format(lib.libname(), self.library_extension)
                     for lib in libs]
        dash_l_libs = [self.dash_l_lib(lib) for lib in libs]
        if base == 'programs/test/dlopen':
            object_deps.append('library/platform.o library/platform_util.o')
        else:
            object_deps.append('$(test_crypto_objects)')
            if self.Library.X509 in libs:
                object_deps.append('$(test_x509_objects)')
            if self.Library.TLS in libs:
                object_deps.append('$(test_ssl_objects)')
        self.target(exe_file,
                    [object_file] + object_deps + lib_files,
                    [sjoin('$(CC)',
                           object_file,
                           sjoin(*object_deps),
                           '$(WARNING_CFLAGS)',
                           '$(COMMON_FLAGS)',
                           '$(LDFLAGS)',
                           '$(PROGRAMS_LDFLAGS)',
                           sjoin(*(dash_l_libs +
                                   list(self.extra_link_flags(base)))),
                           '$(EXTRA_LIBS)',
                           '-o $@')],
                    clean=False,
                    short='LD    $@')
        executables.append(exe_file)

    def programs_section(self) -> None:
        """Emit the makefile rules to build the sample programs."""
        self.comment('Sample programs')
        self.assign('PROGRAMS_CFLAGS',
                    '-I include',
                    self.include_path_options('programs/*/*'),
                    '$(PROGRAMS_EXTRA_CFLAGS)')
        self.assign('PROGRAMS_LDFLAGS',
                    '-L library',
                    '$(PROGRAMS_EXTRA_LDFLAGS)')
        self.add_clean(*['programs/*/*' + ext
                         for ext in (self.assembly_extension,
                                     self.object_extension)])
        programs = self.list_source_files(self.options.source, 'programs/*/*.c')
        executables = [] #type: List[str]
        for src in programs:
            self.program_subsection(src, executables)
        dirs = set(src.target_dir() for src in programs)
        for subdir in sorted(dirs):
            self.target(subdir + '/seedfile', ['tests/seedfile'],
                        ['$(CP) tests/seedfile $@'],
                        clean=False)
        self.assign('programs', *executables)
        self.target('programs', ['$(programs)'],
                    [],
                    help='Build the sample programs.',
                    phony=True)
        self.add_clean('$(programs)')
        self.add_run_target('programs/test/benchmark')
        self.add_run_target('programs/test/selftest')
        self.target('ssl-opt',
                    ['programs/ssl/seedfile',
                     'programs/ssl/ssl_client2$(EXEXT)',
                     'programs/ssl/ssl_server2$(EXEXT)',
                     'programs/test/query_compile_time_config$(EXEXT)',
                     'programs/test/udp_proxy$(EXEXT)',
                     'tests/seedfile'],
                    [],
                    help='Build the programs needed for ssl-opt.sh',
                    phony=True)
        # TODO: *_demo.sh
        self.target('test_zeroize',
                    ['programs/test/zeroize'],
                    ['gdb -x ../tests/scripts/test_zeroize.gdb -nw -batch -nx'])

    def define_tests_common_objects(self) -> None:
        """Emit the definition of tests_common_objects.

        These objects are needed for unit tests and for sample programs
        (or at least for some programs in some configurations), so this
        definition must come before both targets for programs and tests.
        """
        tests_common_sources = self.list_source_files(self.options.source,
                                                      'tests/src/*.c',
                                                      'tests/src/drivers/*.c',
                                                      'tests/src/test_helpers/*.c')
        tests_crypto_objects = []
        tests_x509_objects = []
        tests_ssl_objects = []
        for src in tests_common_sources:
            self.object_target('TESTS', src)
            object_file = src.target(self.object_extension)
            if 'ssl' in object_file:
                tests_ssl_objects.append(object_file)
            elif 'x509' in object_file:
                tests_x509_objects.append(object_file)
            else:
                tests_crypto_objects.append(object_file)
        self.assign('test_crypto_objects', *tests_crypto_objects)
        self.assign('test_x509_objects', *tests_x509_objects)
        self.assign('test_ssl_objects', *tests_ssl_objects)
        self.assign('test_common_objects',
                    '$(test_crypto_objects)',
                    '$(test_x509_objects)',
                    '$(test_ssl_objects)')

    def test_subsection(self, src: SourceFile,
                        executables: List[str],
                        groups: Dict[str, List[str]]):
        """Emit the makefile rules to build one test suite.

        src is a SourceFile object for a .data file.

        This function appens the path to the test executable to the list
        executables.

        If the .data file is part of a group (*.*.data where the part before the
        first '.' identifies a group), add it to the groups dictionary. The
        keys in this dictionary are group names (base names of .function files)
        and the values are lists of dependencies.
        """
        base = os.path.basename(src.base())
        source_dir = src.source_dir()
        try:
            function_base = base[:base.index('.')]
            groups.setdefault(function_base, [])
        except ValueError:
            function_base = base
        data_file = src.relative_path()
        function_file = os.path.join(source_dir, function_base + '.function')
        function_files = self.test_generator.function_files(function_file)
        c_file = os.path.join('tests', base + '.c')
        object_file = os.path.join('tests', base + self.object_extension)
        exe_basename = base + self.executable_extension
        exe_file = os.path.join('tests', exe_basename)
        if function_base in groups:
            groups[function_base].append(exe_file)
        generate_command = self.test_generator.command(function_file, data_file)
        self.target(self.test_generator.target(c_file),
                    ['$(SOURCE_DIR)/' + base
                     for base in ([self.test_generator.script(source_dir)] +
                                  function_files +
                                  [data_file])],
                    ['cd tests && ' + generate_command],
                    short='Gen   $@')
        self.object_target('TESTS', GeneratedFile(c_file),
                           auto_deps=False,
                           deps=self.c_with_dependencies(function_file),
                           extra_flags='$(TESTS_CFLAGS)')
        self.target(exe_file,
                    (self.c_dependencies_only(function_files) +
                     ['$(lib)', '$(test_build_deps)', object_file]),
                    [sjoin('$(CC)',
                           object_file,
                           '$(WARNING_CFLAGS)',
                           '$(COMMON_FLAGS)',
                           '$(LDFLAGS)',
                           '$(TESTS_LDFLAGS)',
                           '$(test_common_objects)',
                           '$(test_libs)',
                           '$(TESTS_EXTRA_OBJECTS)',
                           '-o $@')],
                    clean=False,
                    short='CC    $@')
        executables.append(exe_file)
        # Strictly speaking, the .run target also depends on the .datax
        # file, since running the test reads the .datax file. However,
        # all the dependencies of the .datax file are also dependencies
        # of the test executable, so if the executable is up to date,
        # so is the .datax file.
        self.target('tests/' + base + '.run',
                    [exe_file, 'tests/seedfile'],
                    ['$(SETENV)cd tests && $(RUN) ./' + exe_basename + ' $(RUNS)'],
                    short='RUN   tests/' + exe_basename,
                    phony=True)
        self.target('tests/' + base + '.gmon',
                    [exe_file, 'tests/seedfile'],
                    ['$(SETENV)cd tests && $(RUN) ./' + exe_basename + ' $(RUNS)',
                     'mv tests/gmon.out $@'],
                    short='RUN   tests/' + exe_basename)
        valgrind_log_basename = 'MemoryChecker.{}.log'.format(base)
        valgrind_log = '$(VALGRIND_LOG_DIR_FROM_TESTS)/' + valgrind_log_basename
        self.target('tests/' + base + '.valgrind',
                    [exe_file, 'tests/seedfile'],
                    [sjoin('cd tests &&',
                           '$(VALGRIND) $(VALGRIND_FLAGS)',
                           '--log-file=' + valgrind_log,
                            './' + exe_basename),
                     sjoin('cd tests && ! grep . ' + valgrind_log)],
                    short='VALGRIND tests/' + exe_basename,
                    phony=True)

    def test_group_target(self, base : str, executables : List[str]) -> None:
        """Emit run targets for a test group.

        A test group is a group of test executables that share the same
        .function file.
        """
        use_run_test_suites = False
        shell_code = '''
failures=;
for x in {}; do
$(RUN) ./$$x $(RUNS) || failures="$$failures $$x";
done;
if [ -n "$$failures" ]; then echo; echo "Failures:$$failures"; false; fi
'''.format(' '.join([re.sub(r'.*/', r'', exe) for exe in executables]))
        self.target('tests/' + base + '.run',
                    executables + ['tests/seedfile'],
                    ['$(SETENV)cd tests && ' + shell_code],
                    short='',
                    phony=True)

    def tests_section(self) -> None:
        """Emit makefile rules to build and run test suites."""
        self.comment('Test targets')
        self.assign('TESTS_CFLAGS',
                    '-Wno-unused-function',
                    '-I include',
                    self.include_path_options('tests/*'),
                    '$(TESTS_EXTRA_CFLAGS)')
        self.assign('TESTS_LDFLAGS',
                    '-L library',
                    '$(TESTS_EXTRA_LDFLAGS)')
        self.assign('TESTS_EXTRA_OBJECTS')
        assert self.static_libraries is not None
        self.assign('test_libs',
                    *[self.dash_l_lib(lib)
                      for lib in reversed(self.static_libraries)],
                    '$(EXTRA_LIBS)')
        self.assign('test_build_deps',
                    '$(test_common_objects)', *self.static_libraries)
        self.add_clean(*['tests' + sub + '/*' + ext
                         for sub in ('', '/*')
                         for ext in (self.assembly_extension,
                                     self.object_extension)])
        self.add_clean('tests/*.c', 'tests/*.datax')
        data_files = self.list_source_files(self.options.source,
                                            'tests/suites/*.data')
        executables = [] #type: List[str]
        groups = {} #type: Dict[str, List[str]]
        for src in data_files:
            self.test_subsection(src, executables, groups)
        self.assign('test_apps', *executables)
        for base in sorted(groups.keys()):
            # If there's both a foo.data and a foo.bar.data, the
            # foo.run targets runs the foo executable, and we can't reuse
            # that name for a group.
            if 'tests/' + base in executables:
                continue
            self.test_group_target(base, groups[base])
        self.target('tests', ['$(test_apps)'],
                    [],
                    help='Build the host tests.',
                    phony=True)
        self.target('tests/seedfile', [],
                    ['dd bs=64 count=1 </dev/urandom >$@'])
        self.target('check', ['$(test_apps)', 'tests/seedfile'],
                    ['$(SETENV)cd tests && $(PERL) scripts/run-test-suites.pl --skip=$(SKIP_TEST_SUITES)'],
                    help='Run all the test suites.',
                    short='',
                    phony=True)
        self.target('test', ['check'],
                    [],
                    help='Run all the test suites.',
                    short='',
                    phony=True)
        self.target('test.valgrind',
                    ['$(test_apps:$(EXEXT)=.valgrind)',
                     'tests/seedfile'],
                    [],
                    help='Run all the test suites with Valgrind.',
                    phony=True)
        self.help['tests/test_suite_%.run'] = 'Run one test suite (or a group).'
        self.help['tests/test_suite_%.valgrind'] = 'Run one test suite with valgrind.'
        self.add_clean('$(test_apps)')
        # TODO: test_psa_constant_names.py

    COVERAGE_RULE = """
        rm -rf Coverage
        lcov --capture --initial --directory library -o files.info
        lcov --rc lcov_branch_coverage=1 --capture --directory library -o tests.info
        lcov --rc lcov_branch_coverage=1 --add-tracefile files.info --add-tracefile tests.info -o all.info
        lcov --rc lcov_branch_coverage=1 --remove all.info -o final.info '*.h'
        genhtml --title "Mbed TLS" --keep-descriptions --legend --branch-coverage -o Coverage final.info
        rm -f files.info tests.info all.info final.info descriptions
        """

    def misc_section(self) -> None:
        """Emit miscellaneous other targets.
        """
        if self.options.coverage_targets:
            self.target('lcov',
                        [],
                        [line.strip() for line in self.COVERAGE_RULE.split('\n')],
                        help='Generate test coverage report')

    def help_lines(self) -> Iterable[str]:
        """Return the lines of text to show for the 'help' target."""
        return ['{:<14} : {}'.format(name, self.help[name])
                for name in sorted(self.help.keys())]

    def variables_help_lines(self) -> Iterable[str]:
        """Return the lines of text to show for the 'help-variables' target."""
        env_opts = [(envopt.var, envopt.help)
                    for envopt in _environment_options
                    if envopt.help is not None]
        ad_hoc = [
            ('V', 'Show commands in full if non-empty.')
        ]
        return ['{:<14} # {}'.format(name, text)
                for (name, text) in sorted(env_opts + ad_hoc)]

    def output_all(self) -> None:
        """Emit the whole makefile."""
        self.comment('Generated by {}', ' '.join(sys.argv))
        self.comment('Do not edit this file! All modifications will be lost.')
        self.line('')
        self.settings_section()
        self.line('')
        self.target('default', [self.options.default_target], [], phony=True)
        self.line('')
        self.target('all', ['lib', 'programs', 'tests'],
                    [],
                    help='Build the library, the tests and the sample programs.',
                    phony=True)
        self.line('')
        self.target('pwd', [], ['pwd'], phony=True, short='PWD') # for testing
        self.line('')
        self.library_section()
        self.line('')
        self.define_tests_common_objects()
        self.line('')
        self.programs_section()
        self.line('')
        self.tests_section()
        self.line('')
        self.misc_section()
        self.line('')
        self.target('clean', [],
                    ['$(RM) ' + patterns for patterns in self.clean],
                    help='Remove all generated files.',
                    short='RM    {generated files}',
                    phony=True)
        self.line('')
        self.target('help-variables', [],
                    ['@echo "{}"'.format(line) for line in self.variables_help_lines()],
                    help='Show useful variables to pass on the make command line.',
                    phony=True)
        # The help target must come last because it displays accumulated help
        # text set by previous calls to self.target. Set its own help manually
        # because self.target would set it too late for it to be printed.
        self.help['help'] = 'Show this help listing the most commonly-used non-file targets.'
        self.target('help', [],
                    ['@echo "{}"'.format(line) for line in self.help_lines()],
                    phony=True)
        self.line('')
        self.comment('End of generated file.')

    def generate(self) -> None:
        """Generate the makefile."""
        destination = os.path.join(self.options.dir, 'Makefile')
        temp_file = destination + '.new'
        with open(temp_file, 'w') as out:
            try:
                self.out = out
                self.output_all()
            finally:
                del self.out
        os.replace(temp_file, destination)


class ConfigMaker:
    """Parent class for config.h or mbedtls_config.h builders.

    Typical usage: ChildClass(options).run()
    """

    def __init__(self, options: Options) -> None:
        """Initialize a config header builder with the given command line options."""
        self.options = options
        self.source_file = options.config_file
        include_dir = os.path.join(options.source, 'include', 'mbedtls')
        if os.path.exists(os.path.join(include_dir, 'build_info.h')):
            self.version = 3
            basename = 'mbedtls_config.h'
        else:
            self.version = 2
            basename = 'config.h'
        if self.source_file is None:
            self.source_file = os.path.join(include_dir, basename)
            self.source_file_path = 'include/mbedtls/' + basename
            if not options.in_tree_build:
                self.source_file_path = 'source/' + self.source_file_path
        else:
            self.source_file_path = os.path.abspath(self.source_file)
        self.target_file = os.path.join(options.dir,
                                        'include', 'mbedtls', basename)

    def start(self) -> None:
        """Builder-specific method which is called first."""
        raise NotImplementedError

    def set(self, name: str, value: Optional[str] = None) -> None:
        """Builder-specific method to set name to value."""
        raise Exception("Configuration method {} does not support setting options"
                        .format(self.options.config_mode))

    def unset(self, name: str) -> None:
        """Builder-specific method to unset name."""
        raise Exception("Configuration method {} does not support unsetting options"
                        .format(self.options.config_mode))

    def batch(self, name: str) -> None:
        """Builder-specific method to set the configuration with the given name."""
        raise Exception("Configuration method {} does not support batch-setting options"
                        .format(self.options.config_mode))

    def finish(self) -> None:
        """Builder-specific method which is called last."""
        raise NotImplementedError

    def run(self) -> None:
        """Go ahead and generate the config header."""
        self.start()
        if self.options.config_name is not None:
            self.batch(self.options.config_name)
        for spec in self.options.config_unset:
            for name in re.split(r'[\t ,]+', spec):
                self.unset(name)
        for spec in self.options.config_set:
            m = re.match(r'(?P<name>[0-9A-Z_a-z]+)' +
                         r'(?P<args>\([\t ,0-9A-Z_a-z]*\))?' +
                         r'(?P<sep>[=,]?)', spec)
            if m is None or \
               (m.group('args') is not None and m.group('sep') == ',') :
                raise Exception("Invalid argument to --config-set")
            if m.group('sep') == ',':
                for name in spec.split(','):
                    self.set(name)
            else:
                name = spec[:m.start('sep')]
                value = spec[m.end('sep'):]
                self.set(name, value)
        self.finish()
_config_classes = {} #type: Dict[str, typing.Type[ConfigMaker]]

class ConfigCopy(ConfigMaker):
    """ConfigMaker implementation that copies the config header and runs the config script."""

    def start(self) -> None:
        if not are_same_existing_files(self.source_file, self.target_file):
            shutil.copyfile(self.source_file, self.target_file)

    def run_config_script(self, *args: str) -> None:
        if os.path.exists(os.path.join(self.options.source,
                                       'scripts', 'config.py')):
            cmd = [sys.executable, 'scripts/config.py']
        else:
            cmd = ['perl', 'scripts/config.pl']
        cmd += ['-f', os.path.abspath(self.target_file)] + list(args)
        subprocess.check_call(cmd, cwd=self.options.source)

    def set(self, name: str, value: Optional[str] = None) -> None:
        if value is None:
            self.run_config_script('set', name)
        else:
            self.run_config_script('set', name, value)

    def unset(self, name: str) -> None:
        self.run_config_script('unset', name)

    def batch(self, name: str) -> None:
        self.run_config_script(name)

    def finish(self) -> None:
        pass
_config_classes['copy'] = ConfigCopy

class ConfigExplicit(ConfigMaker):
    """ConfigMaker implementation that makes a config script with only explicitly set options."""

    def __init__(self, *args) -> None:
        super().__init__(*args)
        self.lines = [] #type: List[str]

    def start(self) -> None:
        self.lines.append('#ifndef MBEDTLS_CONFIG_H')
        self.lines.append('#define MBEDTLS_CONFIG_H')
        self.lines.append('')

    def set(self, name: str, value: Optional[str] = None) -> None:
        if value:
            self.lines.append('#define ' + name + ' ' + value)
        else:
            self.lines.append('#define ' + name)

    def unset(self, name: str) -> None:
        self.lines.append('#undef ' + name)

    def finish(self) -> None:
        self.lines.append('')
        self.lines.append('#endif')
        with open(self.target_file, 'w') as out:
            for line in self.lines:
                out.write(line + '\n')
_config_classes['explicit'] = ConfigExplicit

class ConfigInclude(ConfigExplicit):
    """ConfigMaker implementation that makes a config script that #includes the base one."""

    def start(self) -> None:
        source_path = self.source_file_path
        if not os.path.isabs(source_path):
            source_path = os.path.join(os.pardir, os.pardir, source_path)
        self.lines.append('#ifndef MBEDTLS_CHECK_CONFIG_H')
        #TODO: in 2.x, MBEDTLS_USER_CONFIG_FILE needs to go here!
        self.lines.append('#include "{}"'.format(source_path))
        self.lines.append('')

    def finish(self) -> None:
        if self.version < 3:
            self.lines.append('')
            self.lines.append('#undef MBEDTLS_CHECK_CONFIG_H')
            # Avoid a redefinition of this typedef
            self.lines.append('#define mbedtls_iso_c_forbids_empty_translation_units mbedtls_iso_c_forbids_empty_translation_units2')
            self.lines.append('#include "mbedtls/check_config.h"')
            self.lines.append('#undef mbedtls_iso_c_forbids_empty_translation_units')
        super().finish()
_config_classes['include'] = ConfigInclude


class BuildTreeMaker:
    """Prepare an Mbed TLS/Crypto build tree.

    * Create a directory structure.
    * Create symbolic links to some files and directories from the source.
    * Create a config.h or mbedtls_config.h.
    * Create a Makefile.

    Typical usage: BuildTreeMaker(options).run()
    """

    def __init__(self, options: Options) -> None:
        self.options = options
        self.source_path = os.path.abspath(options.source)
        options.in_tree_build = are_same_existing_files(self.options.source,
                                                        self.options.dir)
        self.makefile = MakefileMaker(options,
                                      '.' if options.in_tree_build else 'source')
        if options.config_mode is None:
            if options.config_name is None and not options.in_tree_build:
                options.config_mode = 'include'
            else:
                options.config_mode = 'copy'
        self.config = _config_classes[options.config_mode](options)
        self.submodules = self.makefile.submodules

    def programs_subdirs(self) -> Iterable[str]:
        """Detect subdirectories for sample programs."""
        tops = ([self.options.source] +
                [os.path.join(self.options.source, submodule)
                 for submodule in self.submodules])
        return [os.path.basename(d)
                for top in tops
                for d in glob.glob(os.path.join(top, 'programs', '*'))
                if os.path.isdir(d)]

    def make_subdir(self, subdir: List[str]) -> None:
        """Create the given subdirectory of the build tree."""
        path = os.path.join(self.options.dir, *subdir)
        if not os.path.exists(path):
            os.makedirs(path)

    def make_link(self, target: str, link: str) -> None:
        """Create a symbolic link called link pointing to target.

        link is a path relative to the build directory.

        If the link already exists, it is not modified.
        """
        link_path = os.path.join(self.options.dir, link)
        if not os.path.lexists(link_path):
            os.symlink(target, link_path)

    def link_to_source(self,
                       sub_link: typing.List[str],
                       link: typing.List[str]) -> None:
        """Create a symbolic link in the build tree to sub_link under the source."""
        self.make_link(os.path.join(*([os.pardir] * (len(link) - 1) +
                                      ['source'] + sub_link)),
                       os.path.join(*link))

    def link_to_source_maybe(self, link: typing.List[str]) -> None:
        """Create a symbolic link in the build tree to a target of the same
        name in the source tree in any submodule.

        Check the root first, then the submodules in the order given by
        SUBMODULE_NAMES.
        """
        for submodule in [''] + SUBMODULE_NAMES:
            sub_link = [submodule] + link
            if os.path.exists(os.path.join(self.options.source, *sub_link)):
                self.link_to_source(sub_link, link)

    def link_test_suites(self) -> None:
        # This is a hack due to the weird paths produced by the test generator.
        # The test generator generates a file with #file directives that
        # point to "suites/xxx.function". Since we run the compiler from the
        # top of the build tree rather than from the tests directory,
        # the debug information in the binary contains a path of the form
        # "build-directory/suites/xxx.function" rather than
        # the correct source path. So arrange for this directory to exist.
        # This is only a partial workaround, since it points to the main
        # source tree, but the correct file for any given test may be
        # in a submodule.
        self.make_link('source/tests/suites', 'suites')

    def prepare_source(self) -> None:
        """Generate extra source files in the source tree.

        This is necessary in the Mbed TLS development branch since before 3.0:
        some source files are not checked into version control. Ideally this
        script would know how to generate them in the target directory, but
        this is not implemented yet. As an easier-to-implement stopgap measure,
        generate the files in the source tree.

        This implementation relies on the official Makefile, so it won't work
        when re-running mbedtls-prepare-build for an in-tree build.
        """
        if not os.path.exists(os.path.join(self.source_path,
                                           'library', 'error.c')):
            for name in ('gnumake', 'gmake', 'make'):
                make_command = shutil.which(name)
                if make_command is not None:
                    break
            else:
                raise Exception('No "make" command found to run "make generated_files"')
            subprocess.check_call([make_command, 'generated_files'],
                                  cwd=self.source_path)

    def run(self) -> None:
        """Go ahead and prepate the build tree."""
        for subdir in ([['include', 'mbedtls'],
                        ['library'],
                        ['tests', 'src', 'drivers'],
                        ['tests', 'src', 'test_helpers']] +
                       [['programs', d] for d in self.programs_subdirs()]):
            self.make_subdir(subdir)
        source_link = os.path.join(self.options.dir, 'source')
        if not self.options.in_tree_build and not os.path.exists(source_link):
            os.symlink(self.source_path, source_link)
        for link in [['include', 'psa'], # hack for psa_constant_names.py
                     ['programs', 'test', 'zeroize.c'],
                     ['scripts'],
                     ['tests', 'configs'],
                     ['tests', 'compat.sh'],
                     ['tests', 'data_files'],
                     ['tests', 'opt-testcases'],
                     ['tests', 'scripts'],
                     ['tests', 'ssl-opt.sh']]:
            self.link_to_source_maybe(link)
        self.link_test_suites()
        self.prepare_source()
        self.makefile.generate()
        self.config.run()

CLANG_WARNING_CFLAGS = '-Werror -Wall -Wextra -Wdocumentation -Wno-documentation-deprecated-sync -std=c99 -D_DEFAULT_SOURCE'

"""Named presets.

This is a dictionary mapping preset names to their descriptions. The
description of a preset is a namespace object that represents the options to
set for this preset. The field _help in a description has a special meaning:
it's the documentation of the preset.
"""
_preset_options = {
    '': argparse.Namespace(), # empty preset = use defaults
    'asan': argparse.Namespace(
        _help='Clang with ASan+UBSan, current configuration',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='clang',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=address,undefined -fno-sanitize-recover=all -fno-common -g3',
        WARNING_CFLAGS=CLANG_WARNING_CFLAGS,
    ),
    'asan-gcc': argparse.Namespace(
        _help='GCC with ASan+UBSan, current configuration',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='gcc',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=address,undefined -fno-sanitize-recover=all -fno-common -g3',
    ),
    'cf': argparse.Namespace(
        _help='Constant flow with MSan, current configuration',
        config_set=['MBEDTLS_TEST_CONSTANT_FLOW_MEMSAN'],
        config_unset=['MBEDTLS_AESNI_C'],
        CC='clang',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=memory -g3',
        WARNING_CFLAGS=CLANG_WARNING_CFLAGS,
    ),
    'coverage': argparse.Namespace(
        _help='Build with coverage instrumentation',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        coverage_targets=True,
        CFLAGS='-O0',
        COMMON_FLAGS='--coverage -g3',
    ),
    'debug': argparse.Namespace(
        _help='Debug build',
        CFLAGS='-O0',
        COMMON_FLAGS='-g3',
    ),
    'ecc-heap': argparse.Namespace(
        _help='Like scripts/ecc-heap.sh',
        config_mode='explicit',
        config_set=[
            'MBEDTLS_PLATFORM_C',
            'MBEDTLS_PLATFORM_MEMORY',
            'MBEDTLS_MEMORY_BUFFER_ALLOC_C',
            'MBEDTLS_MEMORY_DEBUG',
            'MBEDTLS_TIMING_C',
            'MBEDTLS_BIGNUM_C',
            'MBEDTLS_ECP_C',
            'MBEDTLS_ASN1_PARSE_C',
            'MBEDTLS_ASN1_WRITE_C',
            'MBEDTLS_ECDSA_C',
            'MBEDTLS_ECDH_C',
            'MBEDTLS_ECP_DP_SECP192R1_ENABLED',
            'MBEDTLS_ECP_DP_SECP224R1_ENABLED',
            'MBEDTLS_ECP_DP_SECP256R1_ENABLED',
            'MBEDTLS_ECP_DP_SECP384R1_ENABLED',
            'MBEDTLS_ECP_DP_SECP521R1_ENABLED',
            'MBEDTLS_ECP_DP_CURVE25519_ENABLED',
            'MBEDTLS_SHA256_C', #necessary for the ECDSA benchmark
            'MBEDTLS_SHA224_C', #In 3.0, SHA256 requires SHA224
            'MBEDTLS_ECP_WINDOW_SIZE=4',
            'MBEDTLS_ECP_FIXED_POINT_OPTIM=1',
        ],
        CFLAGS='-O2',
    ),
    'full': argparse.Namespace(
        _help='Full configuration',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
    ),
    'full-asan': argparse.Namespace(
        _help='Full configuration with Clang+ASan+UBSan',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='clang',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=address,undefined -fno-sanitize-recover=all -fno-common -g3',
        WARNING_CFLAGS=CLANG_WARNING_CFLAGS,
    ),
    'full-asan-gcc': argparse.Namespace(
        _help='Full configuration with GCC+ASan+UBSan',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='gcc',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=address,undefined -fno-sanitize-recover=all -fno-common -g3',
    ),
    'full-debug': argparse.Namespace(
        _help='Full configuration, debug build',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CFLAGS='-O0',
        COMMON_FLAGS='-g3',
    ),
    'full-thumb': argparse.Namespace(
        _help='Full configuration for arm-linux-gnueabi',
        config_name='full',
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='arm-linux-gnueabi-gcc',
        CFLAGS='-Os',
        COMMON_FLAGS='-mthumb',
    ),
    'm0plus': argparse.Namespace(
        _help='Baremetal configuration for Cortex-M0+ target',
        config_name='baremetal',
        default_target='lib',
        CC='arm-none-eabi-gcc',
        CFLAGS='-Os',
        COMMON_FLAGS='-mthumb -mcpu=cortex-m0plus',
    ),
    'mingw': argparse.Namespace(
        _help='MinGW-w64',
        AR='x86_64-w64-mingw32-ar',
        CC='x86_64-w64-mingw32-gcc',
        EXTRA_LIBS='-lws2_32',
        CFLAGS='-O1',
    ),
    'msan': argparse.Namespace(
        _help='Clang Memory sanitizer (MSan), current configuration',
        config_unset=['MBEDTLS_AESNI_C',
                      'MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='clang',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=memory -g3',
        WARNING_CFLAGS=CLANG_WARNING_CFLAGS,
    ),
    'noplatform': argparse.Namespace(
        _help='Full except platform/fsio/net',
        config_name='full',
        config_unset=[
            'MBEDTLS_PLATFORM_C',
            'MBEDTLS_NET_C',
            'MBEDTLS_PLATFORM_MEMORY',
            'MBEDTLS_PLATFORM_PRINTF_ALT',
            'MBEDTLS_PLATFORM_FPRINTF_ALT',
            'MBEDTLS_PLATFORM_SNPRINTF_ALT',
            'MBEDTLS_PLATFORM_VSNPRINTF_ALT',
            'MBEDTLS_PLATFORM_TIME_ALT',
            'MBEDTLS_PLATFORM_EXIT_ALT',
            'MBEDTLS_PLATFORM_SETBUF_ALT',
            'MBEDTLS_PLATFORM_NV_SEED_ALT',
            'MBEDTLS_ENTROPY_NV_SEED',
            'MBEDTLS_FS_IO',
            'MBEDTLS_PSA_CRYPTO_SE_C',
            'MBEDTLS_PSA_CRYPTO_STORAGE_C',
            'MBEDTLS_PSA_ITS_FILE_C',
        ],
        WARNING_CFLAGS='-Werror -Wall -Wextra -std=c99 -D_DEFAULT_SOURCE',
    ),
    'opt': argparse.Namespace(
        _help='Optimized build',
        CFLAGS='-O3',
    ),
    'thumb': argparse.Namespace(
        _help='Default configuration for arm-linux-gnueabi',
        CC='arm-linux-gnueabi-gcc',
        CFLAGS='-Os',
        COMMON_FLAGS='-mthumb',
    ),
    'tsan': argparse.Namespace(
        _help='Clang with TSan, current configuration + pthread',
        config_set=['MBEDTLS_THREADING_C', 'MBEDTLS_THREADING_PTHREAD'],
        config_unset=['MBEDTLS_MEMORY_BUFFER_ALLOC_C'],
        CC='clang',
        CFLAGS='-O2',
        COMMON_FLAGS='-fsanitize=thread -fno-sanitize-recover=all -fno-common -g3',
        WARNING_CFLAGS=CLANG_WARNING_CFLAGS,
    ),
    'valgrind': argparse.Namespace(
        # This is misleading: it doesn't actually run programs through
        # valgrind when you run e.g. `make check`
        _help='Build for Valgrind, current configuration',
        config_unset=['MBEDTLS_AESNI_C'],
        CFLAGS='-g -O3',
    ),
} #type: Dict[str, argparse.Namespace]

"""Default values for some options.

The keys are the field names in the options object.
"""
_default_options = {
    'coverage_targets': False,
    'default_target': 'all',
    'dir': os.curdir,
    'executable_extension': '',
    'indirect_extensions': False,
    'library_extension': '.a',
    'assembly_extension': '.s',
    'object_extension': '.o',
    'shared_library_extension': '.so',
    'source': os.curdir,
}

def set_default_option(options: Options, attr: str,
                       value: typing.Any) -> None:
    if getattr(options, attr) is None:
        setattr(options, attr, value)
    elif isinstance(value, list):
        setattr(options, attr, value + getattr(options, attr))

def handle_cross(options: Options) -> None:
    """Update settings to handle --cross."""
    if options.cross is None:
        return
    # Paths for Ubuntu 18.04 with the packages qemu-user and either
    # gcc-multilib-<ARCH> or gcc-<ARCH> installed.
    set_default_option(options, 'QEMU_LD_PREFIX', '/usr/' + options.cross)
    set_default_option(options, 'CC', options.cross + '-gcc')
    set_default_option(options, 'dir', 'build-' + options.cross)

def set_default_options(options: Options) -> None:
    """Apply the preset if any and set default for remaining options.

    We set defaults via this function rather than via the `default`
    keyword argument to `parser.add_argument` in order to apply
    settings in the correct precedence order: default, then preset,
    then explicit.

    For options that can be used more than once and whose values
    are accumulated in a list, the default is always empty, and a
    preset puts things at the beginning of the list. A command line
    option can only append to the preset, not remove preset elements.
    This is implemented by prepending the preset to the explicit elements
    """
    # Step 1: apply preset.
    if options.preset:
        for attr, value in _preset_options[options.preset]._get_kwargs():
            if attr.startswith('_'):
                continue
            set_default_option(options, attr, value)
            set_default_option(options, 'dir', 'build-' + options.preset)
    # Step 2: handle multi-effect options
    handle_cross(options)
    # Step 3: set remaining defaults.
    for attr, value in _default_options.items():
        set_default_option(options, attr, value)
    for envopt in _environment_options:
        set_default_option(options, envopt.attr, envopt.default)

def preset_help() -> str:
    """Return a documentation string for the presets."""
    return '\n'.join(['Presets:'] +
                     ['{}: {}'.format(name, _preset_options[name]._help)
                      for name in sorted(_preset_options.keys())
                      if hasattr(_preset_options[name], '_help')] +
                     [''])

def arg_type_bool(arg: typing.Union[bool, str]) -> bool:
    """Boolean argument type for argparse.add_argument."""
    if not isinstance(arg, str):
        return arg
    arg = arg.lower()
    if arg in ['1', 't', 'true', 'y', 'yes']:
        return True
    elif arg in ['0', 'f', 'false', 'n', 'no']:
        return False
    else:
        raise argparse.ArgumentTypeError('invalid boolean value: ' + repr(arg))

def main() -> None:
    """Process the command line and prepare a build tree accordingly."""
    parser = argparse.ArgumentParser(formatter_class=argparse.RawDescriptionHelpFormatter,
                                     description=__doc__,
                                     epilog=preset_help())
    for envopt in _environment_options:
        parser.add_argument(envopt.option,
                            dest=envopt.attr,
                            help='{} ({})'.format(envopt.help, envopt.var))
    parser.add_argument('--assembly-extension',
                        help='File extension for assembly files')
    parser.add_argument('--config-file',
                        help='Base config header (config.h or mbedtls_config.h) to use')
    parser.add_argument('--config-mode',
                        choices=_config_classes.keys(),
                        help='What to do with the config header')
    parser.add_argument('--config-name',
                        help='Configuration to set with scripts/config.{pl,py}')
    parser.add_argument('--config-set',
                        action='append', default=[],
                        help='Additional symbol to set in the config header')
    parser.add_argument('--config-unset',
                        action='append', default=[],
                        help='Symbol to unset in the config header')
    parser.add_argument('--coverage-targets',
                        type=arg_type_bool,
                        help='Whether to include test coverage measurement targets')
    parser.add_argument('--cross',
                        help='Run tests on a different architecture with Qemu. Forces an out-of-tree build.')
    parser.add_argument('--default-target',
                        help='Default makefile target (default: all)')
    parser.add_argument('--dir', '-d',
                        help='Build directory to create (default: build-PRESET if given "-p PRESET", otherwise current directory)')
    parser.add_argument('--executable-extension',
                        help='File extension for executables')
    parser.add_argument('--indirect-extensions',
                        type=arg_type_bool,
                        help='Whether to use makefile variable for file extensions')
    parser.add_argument('--library-extension',
                        help='File extension for static libraries')
    parser.add_argument('--object-extension',
                        help='File extension for object files')
    parser.add_argument('--preset', '-p',
                        choices = sorted(_preset_options.keys()),
                        help='Apply a preset configuration before processing other options')
    parser.add_argument('--psa-driver',
                        action='append', default=[],
                        help='PSA crypto driver description file')
    parser.add_argument('--shared-library-extension',
                        help='File extension for shared libraries')
    parser.add_argument('--source', '-s',
                        help='Root directory of the source tree (default: current directory)')
    parser.add_argument('--var',
                        action='append', default=[],
                        help='Extra variable to define in the makefile')
    options = parser.parse_args()
    set_default_options(options)
    builder = BuildTreeMaker(options)
    builder.run()

if __name__ == '__main__':
    main()
